# README

## Лекционное занятие №32

### Тема:

Репозитарий содержит материалы по лекционному занятию №32 посвященному подвинутой работе с локальным состоянием компонентов - хуку `useState`.

**Что это и зачем это нужно?**
На прошлом занятии, мы разбирали понятие локального состояния компонента. При этом, ранее мы работали только с состоянием, которое содержит примитивы. Но это отнюдь не все возможности локального состояния - оно может содержать объекты, массивы - короче, нечто не-примитивное. Иногда это бывает нужно - например, если мы хотим хранить в локальном стейте массив с источником данных для списка, и мы также хотим дать возможность менять этот список (добавлять новые элементы, удалять их, редактировать, и т.д.). Об этом (и не только), сегодня и поговорим.

**Хранение не-примитивов в локальном стейте**
Фактически, хранение не-примитивов в локальном стейте ничем не отличается от хранения примитивов - синтаксис будет ровно тот же. Основная разница будет в изменении значения этого стейта.

Рассмотрим пример. Пусть у нас есть компонент `Human`, у которого есть локальное состояние, которое содержит массив с содержимым карманов. Попробуем добавить еще функции для управления.

```
import { useState } from 'react';

function Human( { humanName} ) {

  const [input, setInput] = useState(''); // это для инпута, в который будем вводить названия вещей чтобы положить в карман
  const [pockets, setPockets] = useState( ['phone', 'keys'] ); // по умолчанию в карманах телефон и ключи

  const addSomething = () => {
    // Кладем в карман
    pockets.push(input);
  }

  // Обработчик события ввода чего-то в инпут
  const handleInputChange = (e) => {
    setInput(e.target.value);
  }

  return (
    <div>
      <h3>Human, my name {humanName}</h3>
      {
        pockets.map(thing => <p key={thing}>{thing}</p>)
      }
      <input type='text' value={input} onChange={handleInputChange}/>
      <button onClick={addSomething}>Add something</button>
    </div>
  )
}
```

Вроде все логично. Но при такой реализации, работать оно будет некорректно. Мы введем нечто в инпут, нажмем кнопку, и ничего не изменится. Изменения мы увидим только тогда, когда опять что-то изменим в инпуте. Нехорошее поведение, почему так?

Потому что наша функция `addSomething` МУТИРУЕТ массив, который лежит в локальном стейте. То есть, она не создает новый массив, а изменяет существующий! И в силу того, что фактически, массив остался тот же (то есть это один и тот же объект в памяти), реакт принимает решение, что ему не нужно перерисовывать компонент.

Побороть эту ситуацию можно двумя путями.

Первый вариант - создать на месте новый массив.
```
  const addSomething = () => {
    // создаем новый массив, в который сложим текущее содержимое карманов, и добавим значение из инпута
    const newPockets = [ ...pockets, input ];
    // обновим локальное состояние. Мы туда пишем НОВЫЙ массив, поэтому реакт будет перерисовывать наш компонент
    setPockets(newPockets);
  }
```

А есть второй вариант, по сути тот же, но чуть короче. О нем сейчас и поговорим.

**Создание нового стейта на основе предыдущего**
Очень часто, нам нужно создать новый стейт на основе предыдущего. При этом, данные из старого стейта будут как-то использованы при создании нового. Например, как в предыдущем примере, с новым массивом. Это можно делать так, как показано выше. Но второй (и более правильный) вариант - это использование функции управления состоянием с аргументом-колбэком.
```
setState( oldState => {
  const newState = // ...
  // do something with oldState, generate newState based on old one
  return newState;
})
```

То есть, теперь наша функция `setState` будет принимать не новое значение фрагмента локального стейта, а функцию-колбэк, которая в аргумент примет старое значение стейта, и должна вернуть новое значение стейта.

Попробуем переписать нашу функцию из компонента `Human`.
```
  const addSomething = () => {
    setPoclets( oldPockets => {
      return [ ...oldPockets, input ];
    })
  }
```

Так чуть короче (можно и еще короче), но суть одна и та же - фактически, мы создаем новый массив, и в него кладем то, что должно быть в новом стейте.

С объектами работает абсолютно точно так же. То есть, если в локальном стейте лежит объект, то вместо того, чтобы как-то менять его свойства, мы должны создать НОВЫЙ объект, с нужными значениями свойств.

**Закрепим практикой**
1. В файле `MountainRoute` создана заготовка компонента, он должен отрендерить маршрут к Одинокой Горе. Точки маршрута хранятся в массиве в компоненте, перенесите их в локальный стейт. Компонент должен отрендерить каждую точку маршрута в виде div-а, в котором будет параграф с названием локации. И все это оберните в div с классом `lonelyMountainRouteContainer`.
2. Добавляем возможность управления маршрутом. В компонент, под список точек, добавьте инпут с плейсхолдером `New point`, и кнопку `Add point`. Нужно сделать так, чтобы при нажатии на кнопку, значение из инпута добавлялось бы в массив точек маршрута.
3. Теперь добавим валидацию. Нужно сделать так, чтобы при нажатии на кнопку, если в инпуте пустой текст, под ним рисовался бы параграф с текстом `Unknown location!`. Задача к обсуждению.
4. Добавляем кнопку "Remove last location". При клике на нее, нужно удалить из списка последнюю точку.
5. Немного усложним. Нам нужно добавить обработчик на кнопку `Remove location` на каждой точке локации. Нужно, чтобы при клике на эту точку, локация удалялась бы из списка.


**Блок дополнительной практики по работе с состоянием**
Реализуем приложение "Список дел", которое позволяет нам составлять список дел.
1. Создаем компонент `TodoItem`, который будет рендерить дело. Дело рендерим в виде div, в котором будет заголовок h2 с названием дела, параграф с описанием дела, кнопка "Удалить дело", и чекбокс со статусом (выполнено/нет). Данные о делах берем в `src/data/todos.js`.
2. Создаем компонент `TodoList`, который будет рендерить список дел с использованием компонента `TodoItem`. Он должен принять в пропсах массив дел, и отрендерить их в виде списка.
3. В компоненте `App`, реализуем локальное состояние `todos`. Начальное значение - импортируем массив дел из `src/data/todos.js`.
4. Дадим возможность добавлять дела. Нужно добавить в наш компонент `App` инпут с кнопкой. В инпут будем вводить имя дела, которое надо добавить. При клике на кнопку, нужно добавлять наше дело в массив в локальном стейте. По умолчанию, дело должно быть не выполнено (то есть completed = false).
5. Реализуйте прицельное удаление дела, чтобы при клике по кнопке "Удалить дело", удалялось бы именно то дело, по которому кликнули.
6. Реализуйте прицельную отметку дела как выполненного. То есть при клике по чекбоксу, нужно менять статус этого дела.


**Поднятие состояния**
Очень часто нам нужно сделать так, чтобы состояние делилось бы между несколькими компонентами, на разных уровнях иерархии. Например, есть форма авторизации, где пользователь авторизуется. И нужно, чтобы имя этого пользователя отобразилось в другом компоненте (например, в компоненте приветствия). Фактически, это разные компоненты, а нам нужно сделать так, чтобы они "делили" между собой состояние. Существует ряд вариантов для решения этой проблемы, сегодня мы поговорим о простейшем из них - поднятии состояния (lifting state).

Идея заключается в том, что необходимый фрагмент состояния "поднимается" по иерархии компонентов до ближайшего общего предка в иерархии компонентов, и пробрасывается через пропсы в необходимые компоненты.

Пока не особо понятно. Попробуем на примерах. Пусть у нас есть компонент, который занимается отрисовкой ToDoList-a, то есть списка дел. Для каждого дела он рисует карточки. Список дел держим в локальном стейте.

```
export default function TodoList() {

  const [todos, setTodos] = useState(['Buy a car', 'Buy cryptocurrencies', 'Feed the dog']);

  return (
    <div>
      { todos.map( todo => <p key={todo}>{todo}</p>)}
    </div>
  );
}
```

Ничего сверхсложного. Теперь предположим, что мы хотим добавить возможность удалять дела в порядке поступления (т.е. удалять последнее дело). Тоже ничего сложного - добавим кнопку и соответствующий обработчик.
```
export default function TodoList() {

  const [todos, setTodos] = useState(['Buy a car', 'Buy cryptocurrencies', 'Feed the dog']);
  const dropTodo = () => {
    setTodos( oldTodos => {
      const newTodos = [...oldTodos];
      newTodos.pop();
      return newTodos;
    });
  }
  return (
    <div>
      { todos.map( todo => <p key={todo}>{todo}</p>)}
      <button onClick={dropTodo}>Drop last todo</button>
    </div>
  );
}
```

Тоже пока все норм. А теперь представим, что мы хотим создать отдельный компонент, который будет рендерить статистику по делам. Пока что вся статистика сводится к отображению количества актуальных дел. И мы хотим по какой-то причине оформить это как отдельный компонент.
```
export default function TodoStats() {

  return (
    <div>
      <p>Now we have {todos.length} todos!</p>
    </div>
  )
}
```

Все бы ничего, но откуда этот компонент должен узнать о списке дел, который является внутренним состоянием другого компонента?

Правильный ответ - мы должны передать этому компоненту список дел в пропсах! Но тогда получается, что компонент `TodoList` должен отрисовывать компонент `TodoStats`! А что если мы хотим разместить их на одном уровне иерархии, например в компоненте `App`?

Вот в этом случае, нам на помощь придет подъем состояния. Наша задача - поднять "источник данных", то есть локальное состояние, на уровень ближайшего общего предка. В нашем случае, это компонент `App`. И мы, в этом случае, перенесем фрагмент локального стейта в `App`, определим там методы для управления этим состоянием (удаление последнего дела, добавление новых, и т.д.), и прокинем это через пропсы в те компоненты, которые в этом нуждаются. Итого, все будет выглядеть так:

```
import React, { useState } from 'react';

export default function App() {

  const [todos, setTodos] = useState(['Buy a car', 'Buy cryptocurrencies', 'Feed the dog']);

  const dropTodo = () => {
    setTodos( oldTodos => {
      const newTodos = [...oldTodos];
      newTodos.pop();
      return newTodos;
    });
  }

  return (
    <div className='App'>
      <TodoList todos={todos} dropTodo={dropTodo} />
      <TodoStats todosCount={todos.length} />
    </div>
  )
}

// TodoList.jsx
export default function TodoList({todos, dropTodo}) {

  return (
    <div>
      { todos.map( todo => <p key={todo}>{todo}</p>)}
      <button onClick={dropTodo}>Drop last todo</button>
    </div>
  )
}

// TodoStats.jsx
export default function TodoStats( {todosCount} ) {

  return (
    <div>
      <p>Now we have {todosCount} todos!</p>
    </div>
  )
}
```

**ВАЖНО!**
Нужно поднимать состояние до БЛИЖАЙШЕГО общего предка. Если состояние без надобности поднимается выше - это влечет лишние ререндеры, и пробрасывание фрагментов этого состояния через компоненты, которые в нем не нуждаются. Помним правило "каждый знает столько, сколько ему положено".

**Закрепим практикой**
1. Пристрелочная. Делаем компонент `LoginForm`, который будет отвечать за попытку авторизации. В нем должны быть 2 инпута, для ввода логина и пароля, и кнопка `Enter`.
2. При нажатии на кнопку, нужно проверить, что оба поля непустые. Если оба непустые - то выводим в консоль логин и пароль. Если пустые - нужно, чтобы над кнопкой показывалось бы сообщение об ошибке "Заполните все поля!". Сообщение показываем в виде параграфа. Здесь нам пригодится условный рендеринг.
3. Теперь научим нашу форму авторизации делиться данными. В компоненте `App`, добавьте заголовок `h2`. Нужно, чтобы при вводе корректных данных (логина и пароля) в форму `LoginForm`, в заголовке появлялся бы текст "Hello, LOGIN". То есть, нам нужно сделать состояние `LoginForm` доступным для `h2`, и в этом нам поможет поднятие состояния.
4. Для компонента `TodoList`, реализуйте удаление дел "прицельно". Нужно чтобы при клике на дело (параграф), оно удалялось бы из списка.
5. Реализуйте компонент `AddTodo`, с помощью которого можно будет добавлять новые элементы в список дел. Надо чтобы он имел заголовок "Enter todo", инпут для ввода названия дела, и кнопку для добавления дела.

### Полезные ссылки
 - Описание [идеи локального состояния](https://react.dev/learn/state-a-components-memory) в документации React.
 - [Описание хука useState](https://react.dev/reference/react/useState) в React. Это именно документация по хуку. Теперь читаем полностью.