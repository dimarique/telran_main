# README

## Лекционное занятие №31

### Тема:

Репозитарий содержит материалы по лекционному занятию №31, посвященному работе с локальным состоянием компонентов - хуку `useState`.

**Что это и зачем это нужно?**
Внутреннее состояние компонента (его также называют локальный стейт) - можно его расценивать как некую "внутреннюю" памть компонента, которая:
 - переживет перерисовку компонента
 - ее изменение спровоцирует перерисовку.

В локальном состянии компонента имеет смысл хранить некие данные, которые характеризуют состояние компонента в данный момент времени. Можно попробовать провести аналогию с человеком. Предположим, "Человек" - это компонент в реальном мире. У каждого компонента "Человек" есть его внутреннее состояние: пульс, температура, рост, вес, и так далее. Если это внутреннее состояние как-то поменяется за счет действий компонента "Человек" - например, он пойдет на спортплощадку и 20 раз подтянется - то это отразится на его внешности (он вспотеет/покраснеет). То есть:
 - происходит некое действие, которое меняет внутреннее состояние
 - изменяется внешность человека
При этом, например, если человек съест что-нибудь - это изменит его вес, и это самую малость но отразится на внешнем виде. Но остальные фрагменты состояния (пульс, температура, ...) - не изменятся, то есть переживут "перерисовку" внешности человека.

Точно так же работает локальное состояние в компонентах React.

**А почему не локальная переменная?**
Может возникнуть логичный вопрос - а почему не локальная переменная? Почему не объявить эту переменную прямо в компоненте, и не пользоваться ей?

Иногда может быть и переменной хватит. Но переменная, в отличие от локального стейта, не "переживет" ререндеринг (перерисовку) компонента. И изменение этой переменной не заставит компонент перерисоваться.

Разберем на примере компонента "Human".
```
export default function Human( {humanName} ) {
  const pulse = 60; // пульс 60 ударов в минуту

  // Функция "выполнить подтягивания", в результате увеличивается пульс
  const makePullUps = () => {
    pulse += 10;
    // Отладочное сообщение - чтобы убедиться, что переменная pulse изменилась
    console.log('After the pullups the pulse is ' + pulse);
  }

  // Отладочное сообщение, будет выводиться каждый раз, когда отрисовывается наш компонент
  console.log('Rendering human with name ' + humanName);

  return (
    <div>
      <h3>Hello, I am {humanName}!</h3>
      <p>Now my pulse is {pulse}</p>
      { pulse > 130 && <span>Wow, pulse is greater than 130! Let me rest a bit.</span>}
      <button onClick={makePullUps}>Make pull ups!</button>
    </div>
  )
}
```

Попробуем отрисовать наш компонент. Как мы видим, он нормально отрисовался, и в консоли видим сообщение о том, что он отрисовался. Теперь нажмем на кнопку. В консоли, мы увидим отладочное сообщение - то есть наш компонент отреагировал на нажатие, и изменилось значение переменной. Но изменений на экране мы НЕ видим. И также мы не видим отладочного сообщения о том, что компонент отрисовался.

Теперь попробуем это сделать с использованием локального состояния. В `React` для этого применяется т.н. "хук" `useState`. Что такое хук? По сути, это обыкновенная функция, определенная `React`, со своими особенностями работы. Есть правило - все хуки именуются с `use`. Мы еще познакомимся с другими хуками, каждый из которых отвечает за свои задачи. Но сегодня нам нужно разобрать хук `useState`.

**Правила применения хуков**
Сразу оговоримся о том, какие есть ограничения по применению хуков.
1. Хуки должны применяться на ВЕРХНЕМ уровне React-компонента (то есть вне `return`, вне функций, и т.д.).
2. Хуки должны применяться ВНЕ условий. То есть, при КАЖДОМ рендере порядок применения хуков должен быть один и тот же.

**Хук `useState`**
С этого хука начинается знакомство с хуками `React`, наверное это основополагающий хук. Он помогает нам создать локальное состояние. И кроме этого, он нам дает инструмент для управления этим локальным состоянием. Выглядит он следующим образом:
```
import { useState } from 'react';

function MyComponent() {

  const [state, setState] = useState(0);
  // ...
  return (
    //...
  )
}
```

Исходя из блока кода выше, мы делаем вывод, что:
 - хук `useState` нам доступен "из коробки", то есть из библиотеки `React`
 - хук применяется на ВЕРХНЕМ уровне компонента, как и было сказано ранее в правилах использования хуков.
 - хук возвращает нам массив из двух элементов, который прнято деструктурировать. Первый элемент - это актуальное значение фрагмента локального состояния. Второй элемент - это ФУНКЦИЯ, которую мы будем использовать, когда захотим поменять локальное состояние.
 - хук ожидает аругмент. Этим аргументом будет начальное состояние (то есть значение, которым мы хотим инициализировать состояние при самом первом рендеринге компонента).

Это не все возможности хука `useState`, об остальных мы поговорим позже.

Довольно слов, перейдем к примеру. Перепишем наш пример с компонентом `Human`.
```
import { useState } from 'react';

export default function Human( {humanName} ) {
  const [pulse, setPulse] = useState(60); // инициализируем начальным значением 60 (ударов в минуту)

  // Функция "выполнить подтягивания", в результате увеличивается пульс
  const makePullUps = () => {
    // Важный момент!!! Когда мы хотим изменить локальный стейт, мы работаем ТОЛЬКО через функцию, которую нам вернул хук useState!!!
    setPulse( pulse + 10 );
  }

  // Отладочное сообщение, будет выводиться каждый раз, когда отрисовывается наш компонент
  console.log('Rendering human with name ' + humanName);

  return (
    <div>
      <h3>Hello, I am {humanName}!</h3>
      <p>Now my pulse is {pulse}</p>
      { pulse > 130 && <span>Wow, pulse is greater than 130! Let me rest a bit.</span>}
      <button onClick={makePullUps}>Make pull ups!</button>
    </div>
  )
}
```

Попробуем понажимать на кнопку. И что же мы видим? Ура, теперь компонент работает штатно, то есть изменение пульса вызывает изменение в визуальном отображении компонента. Более того, каждый раз, когда мы меняем локальное состояние, мы видим, что компонент перерисовывается!

**Важный момент!**
НЕЛЬЗЯ МУТИРОВАТЬ СТЕЙТ! То есть, нельзя напрямую изменять состояние. Если мы в нашей функции `makePullUps` напишем:
```
const makePullUps = () => {
  pulse += 10;
}
```

, то при такой реализации компонент перерисован НЕ БУДЕТ!

Почему так происходит? Потому что когда мы вызываем функцию, которую нам возвращает хук `useState`, `React` ПЛАНИРУЕТ перерисовку компонента. Это важно - он именно ПЛАНИРУЕТ ее, то есть перерисовка не мгновенная (об этом поговорим чуть позже). Но главное в данный момент то, что если мы изменяем стейт напрямую (мутируем), то `React` не будет считать, что нужно перерисовать компонент. И соответственно, это будет работать не так, как задумывалось. Отсюда вывод: мутировать стейт плохо!

**Закрепим практикой**
1. Делаем простой счетчик в локальном состоянии. Нам нужно создать компонент `SimpleCounter`, который будет делать нам счетчик. Он должен рендерить div, который будет содержать параграф с текстом `Clicked N times!`, то есть кол-во кликов по кнопке, и кнопку с текстом `Increment`. При клике на кнопку, увеличиваем счетчик, и отображаем его в параграфе.
2. Добавляем в счетчик вторую кнопку `Decrement`, которая будет уменьшать значение на 1.
3. Вспоминаем условный рендеринг. Нужно сделать так, чтобы счетчик рендерил дополнительный параграф `Multiple of five`, если текущее количество кликов кратно 5.

**Политика "каждый знает столько, сколько ему положено"**
Очень важно для оптимизации. Старайтесь размещать стейт на том уровне иерархии компонентов, где он реально нужен. Потому что изменение стейта влечет за собой перерисовку самого компонента, И перерисовку всех дочерних компонентов (за редким исключением, о котором поговорим позже). Поэтому, размещаем стейт на том уровне иерархии, где он нужен.

**Множество стейтов**
В `React`, нам никто не запрещает создать множество фрагментов локального состояния. То есть, мы можем использовать хук `useState` в одном компоненте столько раз, сколько захотим. При этом, эти фрагменты стейта никак друг на друга не влияют. Если меняется кто-то из них - компонент перерисуется, но остальные не поменяются.
```
export default function Human( {humanName} ) {
  const [pulse, setPulse] = useState(60); // инициализируем начальным значением 60 (ударов в минуту)
  const [temperature, setTemperature] = useState(36.6); // температура тела

  // Функция "выполнить подтягивания", в результате увеличивается пульс
  const makePullUps = () => {
    const newPulse = pulse + 10;
    setPulse( newPulse );
    if (newPulse > 100) {
      // после пульса 100, на каждое увеличение пульса добавляем 0.025 градуса температуры
      setTemperature( temperature + 0.025 );
    }
  }

  // Отладочное сообщение, будет выводиться каждый раз, когда отрисовывается наш компонент
  console.log('Rendering human with name ' + humanName);

  return (
    <div>
      <h3>Hello, I am {humanName}!</h3>
      <p>Now my pulse is {pulse}</p>
      <p>Now my temperature is {temperature}</p>
      { pulse > 130 && <span>Wow, pulse is greater than 130! Let me rest a bit.</span>}
      <button onClick={makePullUps}>Make pull ups!</button>
    </div>
  )
}
```

**Закрепим практикой**
1. Создаем еще один компонент, `SimpleInput`. Это будет div, внутри которого будет input, этому инпуту нужно добавлять класс `simpleInput`. В пропсах будет заходить `placeholder`. Нужно сделать этот инпут контролируемым - то есть, добавить ему внутренее состояние, в котором будем держать то, что введено в инпуте. И на событие изменения инпута `onChange`, нужно менять это состояние (т.е. класть в состояние новое значение инпута).
2. Продолжаем работать с нашим компонентом. Добавляем ему проп `required`. Если этот проп передан, то инпут обязательный. Нужно добавить обработчик события ухода фокуса `onBlur` на наш инпут. Если в него ничего не введено, то нужно отрисовать под инпутом параграф с текстом "Fill this field!". Задача к размышлению.
3. Еще добавляем пропсы, `minLength`, `maxLength`. Это минимальная и максимальная разрешенные длины содержимого поля. Если передан проп `minLength`, и в инпут введено значение меньше, то в параграф выводим сообщение "Too short! Minimal length is: MINLENGTH". Если передан проп `maxLength` и в инпут введено более длинное значение - выводим сообщение "Maximum length is: MAXLENGTH". Тоже к размышлению.
4. Создаем компонент формы `SimpleForm`. В нем должно быть 2 инпута (имя и должность). Инпуты берем стандартные (НЕ НАШ компонент). Также размещаем там кнопку. При нажатии на кнопку, выводим в консоль сообщение "Данные формы: ИМЯ, ДОЛЖНОСТЬ", то есть значения инпутов.
5. Добавляем валидацию. Если хотя бы одно поле пустое - рисуем перед кнопкой параграф с текстом "Fill all fields!".


### Полезные ссылки
 - Описание [идеи локального состояния](https://react.dev/learn/state-a-components-memory) в документации React.
 - [Описание хука useState](https://react.dev/reference/react/useState) в React. Это именно документация по хуку. Пока что имеет смысл ознакомиться только с первым подразделом, до раздела [Updating state based on previous state](https://react.dev/reference/react/useState).