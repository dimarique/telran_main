# README

## Лекционное занятие №28

### Тема:

Репозитарий содержит материалы по лекционному занятию №28, посвященному продолжению знакомства с React.js.

**Сеодняшние темы занятия**
 - условный рендеринг
 - импорт/экспорт
 - подключение стилей

**Условный рендеринг**
Как логично следует из названия, условный рендеринг - это прием, который используется, когда нам нужно отрисовать какой-то фрагмент разметки при выполнении какого-то условия. В JSX нельзя использовать `if-else`, поэтому для условного рендеринга используется несколько других приемов.
1. Рендеринг при выполнении какого-то условия. Этот прием нам нужен в тех случаях, когда мы хотим что-то отрисовать только тогда, когда выполняется условие. Если условие не выполняется - мы ничего рисовать не должны.
```
function SimpleComponent() {

  const rand = Math.random();

  return (
    <div>
      <p>This will be rendered in all cases. Rand is {rand}</p>
      {rand > 0.5 && <p>And this will be only when rand greater than 0.5</p>}
    </div>
  );
}
```

Этот код будет рисовать второй параграф только при условии, что rand > 0.5. Это работает за счет т.н. феномена ускоренного вычисления. Когда JS видит оператор &&, он понимает, что проверять его правую часть имеет смысл только при условии истинности левой части. То есть, если левая часть (где расположено условие), ложная - то правую вычислять и вовсе не надо.

2. Аналог if-else, с использованием тернарного условного оператора. Применяется тогда, когда нам нужно отрисовать один вариант разметки при выполнении условия, и второй вариант - при невыполнении.
```
function SimpleTernaryExample() {

  const rand = Math.random();

  return (
    <div>
      { rand < 0.5 ? <p>Rand is less than 0.5, rendering paragraph</p> : <h3>Rand is greater than 0.5 rendering header</h3>}
    </div>
  );
}
```

Здесь в коде видим тернарный условный оператор. В случае выполнения условия (rand < 0.5), компонент вернет нам разметку из параграфа, а иначе - из заголовка. То есть, тернарный условный оператор хорош тогда, когда нам нужно что-то рисовать и в случае выполнения, и в случае невыполнения условия.

**Закрепим практикой**
1.  Создайте компонент `SimpleHeading`, который будет возвращать нам заголовок с текстом `Hello, conditional rendering!`. В компоненте, нужно создать переменную, в которую запишете случайное значение. Если значение меньше 0.5 - рендерим заголовок h3 с указанным текстом, иначе рендерим заголовок h2.
2. В компоненте `RandomText`, нужно после параграфа который там есть, рендерить еще один параграф с текстом `Small value`. Рендерить его нужно только в том случае, если значение переменной `rand` < 0.5.

**Импорт/экспорт компонентов и логики**
Наши приложения крайне редко состоят только из одного компонента, или же из простых компонентов. Мы будем создавать большие компоненты, которые кроме рисования фрагментов разметки, еще имеют свою логику, внутреннее состояние, в общем сильно сложнее чем те, что у нас есть сейчас. И разумеется, складывать их всех в один файл - сомнительное удовольствие. Имеет смысл разбить их в разные файлы - например так, чтобы каждый компонент был бы в своем файле. И так же дело обстоит и с обычной логикой, которую мы будем писать на JS - мы захотим (во всяком случае должны захотеть), отделить логику от представления, и сложить ее в отдельные файлы. То есть, мы можем создать отдельный JS-файл, который будет содержать какие-то вспомогательные функции, и подключать этот файл к тем компонентам, которые в нем реально нуждаются. Аналогично и с компонентами - мы можем их подключать там, где они реально нужны.

Для этого, существуют директивы импорта и экспорта. Разберем на примере. Предположим, мы хотим создать компонент, который будет рендерить нам обычный заголовок со статичным текстом.

Обычно, файлы компонентов хранят в подпапках каталога src. Создадим там папку components, и в ней создадим новый файл, SimpeHeader.jsx. Имена файлов необязательно должны совпадать с именами содержимых компонентов, но это желательно.

```
function SimpleHeader() {

  return <h1>Hello from Simple Header!</h1>;
}
```

Пока что наш компонент `SimpleHeader` абсолютно бесполезен - потому что та разметка, которую он генерирует, не может быть использована нигде кроме как внутри этого файла.  Для того, чтобы "поделиться" этой разработкой с внешним кодом, нам нужно явно указать, что мы хотим экспортировать из файла, то есть сделать доступным для внешнего кода. Проводя аналогию с ООП - сделать публичным.

```
export default SimpleHeader; // (1)
// export {SimpleHeader}; // (2)
```

В фрагменте кода выше, приведено 2 способа экспорта. Первый - это экспорт по умолчанию. А второй - это "прицельный", именованный экспорт, когда мы хотим сказать, что из файла экспортируется не все, а только какие-то конкретные фрагменты (по именам этих фрагментов). Такое тоже может быть полезно, если мы хотим скрыть часть логики (вспомогательные функции, константы, и т.д.).

Теперь осталось это подключить - то есть воспользоваться этой функциональностью в других компонентах. Для этого, в принимающем компоненте нам нужно указать, что конкретно мы хотим импортировать, и откуда. Воспользуемся нашим компонентом в файле `index.js`.

```
import SimpleHeader from './components/SimpleHeader.jsx; // 1
// import { SimpleHeader } from './components/SimpleHeader.jsx; // 2
```

Здесь тоже 2 варианта. Первый используется тогда, когда в нашем файле-источнике используется `export default`, то есть присутствует экспорт по умолчанию. Второй - именованный импорт - нужен тогда, когда мы хотим что-то прицельно импортировать, иначе говоря - подключить лишь часть функциональности из файла-источника. Тогда, внутри фигурных скобок, мы указываем то, что экспортируется из файла-источника.

Еще интересный момент относительно импортов. В случае с импортом по умолчанию - нам необязательно указывать точное имя того, что экпортируется из файла-источника, мы можем указать "псевдоним". Например:
```
import SimpleAlias from './components/SimpleHeader.jsx';
```

Если в компоненте `SimpleHeader` указан экспорт по умолчанию, то все будет нормально работать. И в принимающем компоненте, мы сможем использовать `SimpleAlias` в качестве имени компонента.

В случае же с именованными экспортами, нам нужно явно говорить о нашем желании использовать псевдоним. Например, так:
```
import {SimpleHeader as MyAliasName} from './components/SimpleHeader.jsx';
```

То есть, тут мы явно указываем, под каким именем мы хотели бы импортировать ту или иную фнукицональность. Это все нужно для ситуаций с коллизиями имен - например, если у нас в проекте подключено несколько библиотек, и каждая из них экспортирует нечто с одним названием.

**Закрепим практикой**
1. Вынести в отдельный модуль (файл SimpleParagraph.jsx) соответствующий компонент из нашего `main.jsx`. Экспорт сделать по умолчанию.
2. Вынести в отдельный модуль (RandomText.jsx) соответствующий компонент из нашего `main.jsx`. Экспорт сделать именованный. Импортировать в `main.jsx` с использованием псевдонима `SimpleRandom`.

**Стилизация компонентов**
И теперь пришла пора поговорить о том, какие есть варианты стилизации наших компонентов. Их тоже несколько.
1. Стандартный способ стилизации. Это - создание обычных CSS-файлов, которые подключаются к компонентам. В нашем приложении, созданном по шаблону Vite, мы можем видеть несколько примеров подключения таких стилей - например, в компоненте `App`, или в файле `main.jsx`. Никакой магии - обычные CSS-файлы, и не менее обычные стили. Основной странный момент - как мы можем подключать файлы стилей к файлам *.js/*.jsx. Ответом на этот вопрос будет тот факт, что стандартная поставка Vite в настройки сборщика проекта, включает загрузчик CSS, который и отвечает за работу со стилями.
2. Менее стандартный способ - это CSS-модули. Они мало чем отличаются от стилей, но дают нам чуть больше гибкости. Чтобы сделать обычный CSS-файл модулем, нужно его переименовать по определенному правилу, и воспользоваться им.

Создадим обычный CSS-файл, и назовем его по правилу именования модулей. Это правило - после имени файла, перед расширением, должно идти слово `module`. Назовем наш файл `SimpleParagraph.module.css`, и разместим рядом с нашим компонентом `SimpleParagraph`.
```
.simpleParagraph {
  font-size: 20px;
  background-color: lightblue;
  border-radius: 5%;
  padding: 10px;
}

.simpleParagraphContainer {
  padding: 10px;
  background-color: aquamarine;
}
```

Теперь, осталось им воспользоваться в компоненте `SimpleParagraph`. Для этого, его нужно подключить как модуль, и правильно воспользоваться.
```
import styles from './SimpleParagraph.module.css';

export default function SimpleParagraph() {
  return (
    <div className={styles.simpleParagraphContainer}>
      <p className={styles.simpleParagraph}>Some text</p>
    </div>
  )
};
```

Обратить внимание стоит на такие моменты:
 - импорт. Мы импортируем стили как импорт по умолчанию, то есть все содержимое.
 - использование. Мы обращаемся к конкретным стилям, как к свойствам объекта, который мы импортировали из модуля стилей.

Такая реализация, дает нам возможность побороться с возможной коллизией имен - например, если нам нужно подключить несколько файлов стилей, которые содержат одинаковые имена классов. Модули решают эту проблему.

3. Инлайн-стили. Это стили, которые мы можем указать прямо в JSX-разметке. Не стоит злоупотреблять этим, потому что нужно разделять стили и логику, но иногда без этого никак.
```
import styles from './SimpleParagraph.module.css';

export default function SimpleParagraph() {
  return (
    <div className={styles.simpleParagraphContainer}>
      <h3 style={{backgroundColor: 'red'}}>Inline styles are applied here!</h3>
      <p className={styles.simpleParagraph}>Some text</p>
    </div>
  )
};
```

Обратите внимание на заголовок h3. Он как раз содержит инлайн-стили. И тут тоже следует обратить внимание на несколько моментов:
 - инлайн-стили идут в атрибуте `style`, и он применим только для элементов, соответствующих стандартным тегам.
 - этот атрибут должен содержать объект, поэтому тут двойные фигурные скобки. Первые - это говорит о том, что здесь будет динамика, а вторые - это литерал объекта.
 - свойствами этого объекта будут имена CSS-правил, при одном уточнении. Вместо тире используем camelCase. То есть, `background-color` -> `backgroundColor`, `border-radius` -> `borderRadius`, и т.д.

**Закрепим комплексной практикой**
1. Пристрелочная задача. Делаем компонент, который будет отображать "копирайт" нашего проекта. Это должен быть параграф, с текстом "Учебный проект. Все права защищены. 2024". Для символа копирайта используем `&#169;`.
2. Добавляем стили. Создаем CSS-модуль для стилей нашего компонента. Он должен занимать всю ширину, цвет текста - серый, выравнивание текста по центру, размер шрифта 14.
3. Теперь попробуем создать компонент `PersonalCard`, который будет отвечать за отрисовку карточки с данными о разработчике. Карточка содержит:
 - заголовок h3 с ФИО
 - параграф с названием вашей квалификации (не скромничаем, но и не теряем связь с реальностью)
 - параграф "О себе" - здесь напишем пару слов о том, какие мы классные.
 - аватар (картинка - в идеале, с фото). Хорошо будет, чтобы картинка была круглая
4. Стилизуем компонент. Нужно создать класс `personalInfoContainer`. Нужно сделать так, чтобы ФИО, квалификация и описание занимали бы половину ширины, а остальное занимала бы картинка. Также, нужно будет стилизовать и изображение - задать ему ширину 100% контейнера, и соотношение сторон 1:1 (aspect-ratio). Это все тоже нужно сделать в виде CSS-модуля.
5. Делаем компонент `Advantages`. Он будет отрисовывать преимущества работы с нами. Это будет список наших "скиллов". Он содержит 3 скилла: Ответственность, Качество, Оперативность. Каждый скилл рисуем как div, в котором есть заголовок h6 с названием скилла, и параграф с кратким описанием (например, "Отвечаю за каждую строчку кода, клянусь честное слово!"). И стилизуем список. Делаем так, чтобы наши элементы списка размещались бы в одну строку.

### Полезные ссылки
 - Описание [условного рендеринга](https://react.dev/learn/conditional-rendering) в React
 - [Импорт/экспорт](https://react.dev/learn/importing-and-exporting-components). Можно также посмотреть приведенные там ссылки на спецификацию MDN.