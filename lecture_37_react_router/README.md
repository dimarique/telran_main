# README

## Лекционное занятие №37

### Тема:

Репозитарий содержит материалы по занятию, посвященному работе с библиотекой `react-router`.

### Цели занятия
- повторение и закрепление знаний;
- решение задач.

### Зачем это нужно
Пока что, мы говорили об одностраничном приложении, т.е. Single Page Application. При такой ситуации, все компоненты рендерятся на одной странице, которая доступна по конкретному адресу. Но такого зачастую мало - нужно реализовать многостраничное приложение. То есть, чтобы приложение рендерило разные части на разных адресах - например, на главной странице рендерился бы перечень товаров, на странице корзины - корзина, была бы форма авторизации, и так далее. Просто средствами React, это реально, но проблематично, потому что фактически приложение все еще будет рисоваться на одном адресе. Поэтому, используются вспомогательные библиотеки, маршрутизаторы (роутеры), которые помогают имитировать многостраничность приложения. Одной из таких библиотек, наверное самой популярной, является react-router. О ней сегодня и поговорим.

В официальной документации, описывается два подхода: как фреймворк, и как библиотека. Мы рассмотрим второй подход, который поможет нам без особых сложностей добавить маршрутизацию в наше приложение.

### react-router
Зависимость уже добавлена в проект, поэтому можно сразу начинать работать.

**Добавление роутера в проект**
Добавление роутера в проект - очень несложная задача. Нужно "обернуть" наше приложение в провайдер роутера, и затем собственно указать, как будет работать маршрутизация. Дальше всю работу берет на себя библиотека.

```
import React from "react";
import ReactDOM from "react-dom/client";
import { BrowserRouter } from "react-router";
import App from "./app";

const root = document.getElementById("root");

root.render(
  <BrowserRouter>
    <App />
  </BrowserRouter>
);
```

Первым шагом мы оборачиваем наше приложение в провайдер роутера. Мы используем `BrowserRouter`, чаще всего используется именно эта обертка. Кроме нее, есть и другие варианты, например `HashRouter`, о них можно почитать на их официальном сайте.

**Создание маршрутов**
Созданием маршрутов ведают компоненты `Routes`, `Route` библиотеки `react-router`. Это компоненты-обертки, в которые мы оборачиваем наши компоненты. За счет этих оберток, библиотека будет сопоставлять фактический URL-адрес с путем, указанным в компоненте (`Route`), и в случае соответствия, компонент будет отрисован.

Попробуем разобрать на примере. Предположим, что в нашем приложении есть 3 страницы. Будем очень оригинальны, и сделаем для них компоненты `Page1`, `Page2`, `Page3` соответственно. И добавим в них какие-то параграфы и заголовки с содержимым. Это все создано в папке `src/pages`.

Если мы просто отрендерим их в компоненте `App`, то они так и будут рисоваться один под другим, вне зависимости от адреса страницы. А давайте поставим задачу: нужно чтобы эти страницы рендерились в зависимости от адреса. То есть, если адрес в строке браузера будет `localhost:3000/page1` - то рендерим только первую страницу. Если `localhost:3000/page2` - только вторую, и т.д. Реализовать это имеющимися у нас средствами возможно, но довольно проблематично. Воспользуемся библиотекой `react-router`.

```
import './App.css';
import { Routes, Route } from "react-router";
import Page1 from './pages/Page1';
import Page2 from './pages/Page2';
import Page3 from './pages/Page3';

function App() {

  return (
    <div className="App">
      <Routes>
        <Route path="/page1" element={<Page1 />} />
        <Route path="/page2" element={<Page2 />} />
        <Route path="/page3" element={<Page3 />} />
      </Routes>
    </div>
  );
}
```

И теперь, если мы введем в адресной строке `localhost:3000/page1` - то мы окажемся на первой странице нашего приложения. При этом, вторая и третья отрисованы не будут. То есть, рисуется только тот маршрут (роут), чей проп `path` соответствует фактическому адресу страницы. Путь /page1 - это значит "корневой адрес сервиса, плюс /page1".

**Маршрут по умолчанию**
То, что мы сделали ранее, выглядит неплохо, но мы можем обратить внимание на то, что при заходе на адрес `localhost:3000` мы видим фактически пустую страницу, и предупреждение в консоли, о том что не найдено совпадающих маршрутов. Было бы неплохо сделать так, чтобы при заходе на "базовый" маршрут, показывалась бы, например, первая страница.  Тут также есть несколько вариантов, самый простой из которых - прописать этой странице пустой проп `path`, вот так:
```
<Route path="/" element={<Page1 />} />
```

Теперь наша первая страница показывается "по умолчанию", а вторая и третья - только при условии совпадения маршрутов.

**Компоненты вне роутов**
Зачастую, нам нужно сделать так, чтобы какие-то компоненты были отрендерены при любом роуте. Например, отрендерить шапку и подвал сайта, или навигационное меню, или панель справа/слева. Тут все просто - нужно вынести компонент за пределы обертки `Routes`. Примерно так:
```
<div className="App">
  <h2>This header will be rendered in ALL cases, independently of the route</h2>
  <Routes>
    <Route path='/page1' element={<Page1 />} />
    <Route path='/page2' element={<Page2 />} />
    <Route path='/page3' element={<Page3 />} />
  </Routes>
  <Copyright />
</div>
```

В примере выше, и заголовок, и копирайт будут отрисованы всегда, вне зависимости от адреса страницы.

**Закрепим практикой**
1. В папке `src/pages` добавьте компонент `Home.jsx` - это будет наша "домашняя страница". Пусть этот компонент рендерит div с заголовком h2 (текст Welcome!), и параграфом с текстом "This is our home page, do not leave too fast!". Также создайте в той же папке компонент `About.jsx` - типа компонент с информацией о нашей организации, он будет рендерить div, внутри которого будет параграф с текстом "Please, have a patience - we will add this info later!".
2. Добавьте роутер в приложение, и сделайте так, чтобы `Home` был базовым маршрутом, а `About` был бы доступен по адресу `/about`.
3. Сделайте так, чтобы на странице, вне зависимости от маршрута, всегда рендерился бы заголовок с текстом "This page uses react-router!".
4. Задача "со звездочкой". Сделайте компонент `src/components/NavMenu.jsx`, который будет содержать навигационное меню. Оно должно пока что рендерить `nav`, в котором будет `ul` с двумя элементами: Home, About. Разместите это меню слева от содержимого страницы (типа левая панель), так, чтобы оно рендерилось вне зависимости от адреса страницы.

**Вложенные роуты**
Иногда перед нами стоит задача выстроить вложенный маршрут, вида `/products/categories`. Предположим, у нас есть еще парочка компонентов, Page2Flex, Page2Grid. И мы хотим сделать так, чтобы по маршруту `page2/flex` рендерился бы  Page2Flex, по `page2/grid` рендерился бы Page2Grid. Тут нам помогут вложенные роуты.

Чтобы применить вложенный роут, нужно выполнить 2 шага. Первый - собственно, сделать вложенный роут.
```
  <Routes>
    <Route path='/page1' element={<Page1 />} />
    <Route path='/page2' element={<Page2 />}>
      <Route path='flex' element={<Page2Flex />} />
      <Route path='grid' element={<Page2Grid />} />
    </Route>
    <Route path='/page3' element={<Page3 />} />
  </Routes>
```

Обратите внимание, мы НЕ СТАВИМ слэш во вложенных маршрутах!!!

А второй шаг - это воспользоваться еще одним компонентом из библиотеки, `Outlet`, с помощью которого мы укажем, в каком конкретно месте родителя мы хотим отрисовать вложенный роут.
```
import { Outlet } from 'react-router';

export default function Page2() {

  return (
    <div className="page page2">
      <h2>This is the second page of our app</h2>
      <p>It also contains this small dummy text, and contains small grid below.</p>
      <Outlet />
    </div>
  )
}
```

И вместо аутлета, будет подставлен тот компонент, который должен быть отрисован в соответствии с маршрутом.

**Закрепим практикой**
1. Сделайте так, чтобы по маршруту `/about/contacts` рендерилось бы наше сообщение со страницы `about`, а под ним - компонент со списком контактов (произвольный текст с емейлами).
2. По маршруту `/about/shops` должно рендериться наше сообщение со страницы `about`, а под ним - компонент с перечнем магазинов сети (2-3 div-а с заголовком h4 который содержит название магазина, и параграфом, который содержит адрес).

**Ссылки**
Пока что, мы не сделали нормальную маршрутизацию, потому что у нас нет ссылок. То есть, пользователь, чтобы попасть на конкретную страницу, вынужден вводить адрес в адресной строке. Это не хорошо. Нам помогают ссылки (компоненты `Link`, `NavLink`) из библиотеки `react-router`. С помощью этих ссылок мы делаем "переход" по маршруту нашего приложения. Выглядит это так (пример из официальной документации):

```
import { NavLink, Link } from "react-router";

function Header() {
  return (
    <nav>
      {/* NavLink makes it easy to show active states */}
      <NavLink
        to="/"
        className={({ isActive }) =>
          isActive ? "active" : ""
        }
      >
        Home
      </NavLink>

      <Link
        to="/concerts/salt-lake-city"
      >
        Concerts
      </Link>
    </nav>
  );
}
```

Здесь мы видим пример использования обеих компонентов. Первый, `NavLink`, облегчает манипулирование отображением в зависимости от состояния (ссылка активна/неактивна). Второй - просто ссылка. Объединяет их то, что оба имеют проп `to`, который содержит маршрут, куда должна вести эта ссылка.

**Закрепим практикой**
Добавим интерактива в наше навигационное меню в левой панели. Сделайте так, чтобы при клике на `Home`, мы возвращались бы домой ('/'), а при клике на About - на страницу `About`.


### Полезные ссылки
[Библиотека react-router](https://reactrouter.com/start/library/routing) - официальная документация проекта.