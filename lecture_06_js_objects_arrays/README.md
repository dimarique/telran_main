# README

## Лекционное занятие №6

### Тема:

Репозитарий содержит материалы по лекционному занятию №6, посвященному работе с массивами и объектами в JS.

### Объекты
На предыдущем занятии, мы упомянули о том, что в JS присутствует объектный тип данных. Поговорим о нем подробнее.

Что же такое объекты? Если "по-научному", это ассоциативные массивы. То есть это наборы пар "ключ-значение". Каждому ключу (который уникальный в пределах объекта), соответствует какое-то значение. Это можно сравнить с коробкой для деталей у радиолюбителя: большая коробка с множеством отсеков, на каждом отсеке приклеен ярлык (это ключ), и в каждом отсеке что-то лежит (это значение).

Объекты используются для хранения сложных сущностей. Например, нам нужно хранить данные о человеке: его ФИО, возраст, пол, дату рождения и т.д. Использовать примитивы (типа строки, числа и т.д.) - такое себе. И здесь нам как раз помогут объекты.

Создать объект можно несколькими способами, самый распространенный - это литерал объекта (`{}`).
```
const human = {}; // создаем пустой объект
```

Далее, мы можем "заполнять" наш объект нужными нам свойствами. Делается это так:
```
human.name = 'Vasya';
human.lastname = 'Ivanov';
```

То есть, мы заполняем наш объект. Мы пишем имя объекта (human), далее ставим точку, и после точки указываем имя свойства, которое мы хотим дать этому объекту. Это "точечная нотация". При этом важно помнить, что имена свойств должны быть уникальными в пределах объекта. И если мы попробуем записать в объект свойство, которое там уже есть - то значение старого свойства затрется новым.

В качестве значений может быть все, что угодно - примитивы, объекты, массивы, функции, ...

Мы можем сразу указать известные свойства при создании объекта:
```
const human = {
  name: 'Vasya',
  lastname: 'Ivanov',
  skills: {
    programming: 10,
    communication: 10
  }
}
```

Обратите внимание на синтаксис: при таком задании свойств объекта, мы их разделяем запятыми!

Доступ к свойствам объекта - через ту же точку. Например:
```
const vasyaName = human.name;
```

**Закрепим практикой**
1. Создать объект с данными о себе: имя (firstname), фамилия (lastname), любимый цвет (favColor), любимое число (favNumber).
2. Добавить в объект с данными о себе свойство `isStudent`, со значением `true`.
3. Добавить в объект с данными о себе свойство `classes`, которое будет содержать массив с названиями курсов, которые Вы посещаете.
4. Задача со звездочкой. В объект с данными о себе, добавить свойство `address`, которое будет содержать другой объект со свойствами `street`, `city`.
5. Написать функцию `createHumanInstance`, которая будет принимать в аргументах имя, фамилию и дату рождения человека, и должна возвращать объект со свойствами `firstname`, `lastname`, `dateOfBirth`.

**Квадратные скобки**
До сих пор, мы работали со свойствами объекта только через точечную нотацию. Такой способ хорош тогда, когда мы на этапе написания кода уже знаем имя свойства. Что имеется в виду: например, нам с сервера приходит объект с данными товара. Мы точно знаем (потому что мы об этом договорились с разработчиками бэка), что у объекта есть свойства `name`, `price`. И мы спокойно используем эти свойства через точечную нотацию.

Но иногда (очень часто!), возникают ситуации, когда нам нужно обратиться к такому свойству объекта, чье имя мы узнаем только на этапе выполнения кода. Например, у нас есть объект, который характеризует героя компьютерной игры, и у него есть свойства, которые отвечают за снаряжение этого героя.
```
const hero = {
  armour: 'Кольчуга',
  helmet: 'Стальной шлем',
  shied: 'Дубовый щит',
  sword: 'Булатный меч'
}
```

Герой попадает в ситуацию, когда у него улучшат один из элементов снаряжения. Какой - определит сюжет игры. То есть, имя свойства будет определено во время ВЫПОЛНЕНИЯ кода. Например, так:
```
const propToUpgrade = Math.random() > 0.5 ? 'armour' : 'sword';
```

То есть, в константу `propToUpgrade`, на этапе ВЫПОЛНЕНИЯ кода, будет записано имя того свойства объекта, которое будем улучшать. И нам нужно сказать, что это свойство будет улучшено, добавив к нему слово "Супер". Если бы мы на этапе написания кода четко знали, какое свойство улучшить (например, броню), мы бы так и написали:
```
hero.armour = 'Супер ' + hero.armour;
```

Но у нас нет имени свойства - нам нужно сказать, что в качестве имени свойства нужно использовать ЗНАЧЕНИЕ другой переменной (в нашем случае, `propToUpgrade`). И вот тут на помощь приходит нотация с квадратными скобками.
```
hero[propToUpgrade] = 'Супер ' + hero[propToUpgrade];
```

Здесь мы как бы говорим: "возьми то, что указано в квадратных скобках, вычисли значение, и результатом будет как раз имя того свойства, с которым тебе надо работать".

**Закрепим практикой**
1. У нас есть объект `human`, который содержит данные о человеке. С помощью метода `prompt`, запросить у пользователя строку, которая будет содержать имя одного из свойств этого объекта. Вывести это свойство в консоль.
```
const human = {
  name: 'Ivan',
  lastname: 'Petrov',
  dateOfBirth: '02.08.1968',
  address: {
    street: 'StreetName',
    city: 'City'
  }
}
```
2. У нас есть объект, который содержит данные о персонаже компьютерной игры, гноме. Нужно написать функцию `giveWeapon`, которая будет вооружать нашего гнома. Функция принимает 2 аргумента: название оружия (строка) и уровень владения этим оружием (число). Задача - чтобы при вызове функции, в объект `dwarf` добавлялось бы соответствующее свойство.
```
const dwarf = {
  name: 'Torin',
  lastname: 'The Oakshield'
}
```

### Несуществующие свойства
Если при работе с объектом, мы пытаемся обратиться к свойству, которого в объекте не существует - то ОШИБКИ НЕ БУДЕТ! Результатом такого обращения будет `undefined`.

```
const timon = {
  name: 'Timon',
  kind: 'Suricate'
}

// Обращаемся к существующему свойству объекта
console.log( timon.name ); // Timon
// Обращаемся к несуществующему свойству
console.log( timon.age ); // undefined - у объекта нет свойства age
```

Чтобы проверить наличие свойства у объекта, есть несколько способов, мы пока что рассмотрим способ через `in`.

```
const obj = { name: 'Vasya' };
if ( name in obj ) {
  console.log('There is a name!'); // все норм
}

if ( age in obj ) {
  console.log('It has age!'); // это не выполнится
} else {
  console.log('There is no age!'); // это выполнится
}
```

Есть еще один вариант, выглядит он так:
```
const obj = { name: 'Petr' };
if (obj.name) {
  console.log('There is a name');
}

if (obj.age) {
  console.log('There is age!');
} else {
  console.log('There is no age');
}
```

Такая конструкция работает за счет т.н. `truthy` (истинных), и `falsy` (ложных) значений. В JS ложными значениями являются `null`, `undefined`, `NaN`, 0, пустая строка, `false`. Все остальные значения являются истинными. Таким образом, запись `if (obj.name)` читается как `if (obj.name является истинным значением)`. Если мы обращаемся к несуществующему свойству, то мы получим `undefined`, которое является ложным значением, и условие не выполнится.

**Закрепим практикой**
1. Дан блок кода:
```
const person = {
  name: 'Bolg',
  race: 'Orcs'
};
```

Проверьте, есть ли у объекта свойство `weapons`. Если есть - выведите в консоль `He is armed!`. Иначе - выведите в консоль `No weapons!`.
2. Напишите функцию `checkExistence`, которая принимает в аргументах объект, и имя свойства. Если у объекта есть это свойство - нужно вывести в консоль сообщение `This object has property ИМЯ_СВОЙСТВА, its value is ЗНАЧЕНИЕ_СВОЙСТВА`. Иначе - выводит в консоль `No property with name ИМЯ_СВОЙСТВА`. Подсказка: здесь нам нужно работать с нотацией квадратных скобок для доступа к вычисляемым свойствам.


### Массивы
Как мы уже выяснили, объекты в JS хранят свои свойства в виде пар "ключ-значение". Иногда, нам нужно упорядоченное хранение элементов. И вот здесь нам как раз и пригодятся массивы. Таким образом, массив - это упорядоченная коллекция.

Создать массив в JS можно несколькими способами:
```
const arr = [];
const nArr = new Array();
```

В основном, используется первый вариант записи, через квадратные скобки. Мы можем также задать элементы массива:
```
const arr = ['Timon', 'Pumba', 'Simba'];
```

Элементы массива хранятся в нем в порядке добавления. Каждый элемент имеет свой индекс (порядковый номер), при этом нумерация начинается с нуля. Мы можем получить доступ к элементу массива по индексу:
```
const timon = arr[0];
const pumba = arr[1];
```

Можно перезаписывать элементы массива:
```
arr[2] = 'Tukano';
// теперь в массиве arr вместо Симбы - Тукан.
```

**Длина массива** - это количество элементов, добавленных в массив. Длина массива хранится в свойстве `length`. Тут есть небольшой нюанс, о котором имеет смысл помнить:
```
const arr = [1,2,3];
console.log(arr.length); // 3 - потому что 3 элемента
arr[9] = 4; // ставим элемент на 10-ю позицию в массиве
console.log(arr.length); // 10 - потому что у нас последняя занятая позиция - 10.
```

То есть, свойство length отображает не актуальное количество элементов, а последнюю занятую позицию.

Также, в JS нет понятия выхода за границу массива - то есть если мы пытаемся добавить элемент на позицию, которая больше текущей длины - то массив "растянется".

В массив можно складывать любые элементы вперемешку: строки, числа, объекты - все, что угодно.

**Закрепим практикой**
1. Создать массив из строк, в котором будут строки "HTML", "CSS", "JS".
2. Создать массив из объектов, в котором будут 2 объекта. У каждого должно быть свойство name. Имя первого - Timon, имя второго - Pumba.

**Advanced**
В JavaScript, массивы "под капотом" являются объектами. В этом легко убедиться, использовав оператор `typeof`. Почему так - вопрос к разработчикам JS.

### Методы работы с массивами без колбэка
Массивы имеют широкий спектр методов, то есть функций, которые доступны нам "из коробки". Эти методы облегчают работу с массивами, скрывая оптимальную реализацию наиболее распространенных операций. Рассмотрим некоторые из них.

**Блок добавления/удаления элементов из массива**
1. Метод `push` - добавить элемент(ы) в конец массива ("запихать" элемент в массив). Возвращает новую длину массива. Принимает произвольное число аргументов, через запятую.
```
let arr = [1,2,3];
arr.push(4);
console.log(arr); // [1,2,3,4]

arr.push(5,6,7);
console.log(arr); // [1,2,3,4,5,6,7]
```
2. Метод `pop` - удалить последний элемент из массива. Возвращает удаленный элемент.
```
let arr = [1,2,3];
const last = arr.pop();
console.log(arr); // [1,2]
console.log(last); // 3
```
3. Метод `unshift` - добавить элемент(ы) в начало массива. Возвращает новую длину массива. Принимает произвольное число аргументов, через запятую.
```
let arr = [1,2,3];
arr.unshift(4);
console.log(arr); // [4,1,2,3]

arr.unshift(5,6,7);
console.log(arr); // [5,6,7,4,1,2,3]
```
4. Метод `shift` - удалить первый элемент из массива. Возвращает удаленный элемент.
```
let arr = [1,2,3];
const first = arr.shift();
console.log(arr); // [2,3]
console.log(first); // 1
```

**Закрепим практикой**
1. добавить элемент в конец массива чисел (число 45);
2. добавить несколько элементов в конец массива чисел (числа 45, 68, 23);
3. добавить объект в конец массива объектов (создать новый объект товара, по образу существующих).
4. удалить последний элемент из массива чисел.
5. добавить элемент в начало массива чисел (число 9)
6. удалить первый элемент из массива чисел

**Метод slice**
Это метод, который позволяет сделать "срез" массива. Он возвращает новый массив, который содержит "срез" исходного.
```
const arr = [1,2,3,4,5,6,7,8,9];
const newArr = arr.slice(2,5);
console.log(newArr); // [3,4,5]
```

Метод принимает обязятаельный первый аргумент - откуда начинать срез. И необязательный второй - где заканчивать срез. Срез включает элемент с позиции старта, и не включает элемент с позиции финиша. Если не передан второй аргумент - то будет сделан срез от позиции старта до конца массива.

**Закрепим практикой**
1. Создать массив, который будет содержать элементы массива `numbers` с третьего по шестой (включительно).
2. Создать массив, который будет содержать элементы массива `strings` с четвертого и до конца.

**Метод splice**
Этот метод заслуживает отдельного описания. Он позволяет вставлять элемент(ы) в середину массива. Или же заменять часть массива другими элементами.
```
splice(start, deleteCount, item1, item2, /* …, */ itemN)
```
*start* - позиция в массиве, с которой мы начинаем.
*deleteCount* - сколько элементов в массиве нам нужно удалить, начиная с позиции *start*
*item1, item2, ..., itemN - элемент(ы), которые нужно вставить вместо удаленных элементов на позицию *start*

Пример:
```
const arr = [1,2,3,4,5,6,7];
// заменим числа 4,5 на числа 100, 200
arr.splice(3, 2, 100, 200);
// то есть мы говорим "удали в массиве arr 2 элемента начиная с позиции 3, и вместо них вставь элементы 100, 200
console.log(arr);

// теперь предположим, что мы хотим просто удалить эти числа из массива
arr.splice(3, 2);
// "удали в массиве arr 2 элемента, начиная с позиции 3, и не вставляй вместо них ничего"
console.log(arr);

// а теперь хотим просто вставить элементы 250, 350 в массив, начиная с позиции 4
arr.splice(4, 0, 250, 350);
// "удали в массиве arr 0 элементов, начиная с позиции 4, и вставь 250, 350 в массив, начиная с этой позиции
console.log(arr);
```

Метод хорош тогда, когда нам нужно или вставить элемент(ы) в середину массива, или заменить группу элементов в середине массива, или удалить группу элементов в середине массива.

**Закрепим практикой**
1. заменить в массиве элементы: вместо строк 'simple', 'and', 'lowercased', теперь должна быть строка 'tiny'.
2. вставить в массив чисел числа 121, 144 на позицию 5.
3. удалить из массива strings 3 элемента, начиная с 3-й позиции

### Полезные ссылки
 - (Русскоязычный гайд)[https://learn.javascript.ru/function-basics] по функциям.
 - (Function Expression vs Function Declaration)[https://learn.javascript.ru/function-expressions]
 - Очень толково об (объектах)[https://learn.javascript.ru/object]. Особое внимание уделить (этому)[https://learn.javascript.ru/object#kvadratnye-skobki].
 - Все о (массивах)[https://learn.javascript.ru/array]
 - Справочник (методов)[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array] массивов