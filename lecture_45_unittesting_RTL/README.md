# README

## Лекционное занятие №45

Репозитарий содержит материалы по лекционному занятию №45, посвященному работе с юнит тестами, и библиотекой `Jest`.

### Unit тестирование
**Пирамида тестирования** - это абстрактное представление покрытия всего проекта тестами. Представляет собой пирамиду (странно, правда?), которая отображает разбивку тестов по уровням. Чем выше уровен в пирамиде, тем меньше количество таких тестов. В базовом варианте, состоит из 3 уровней:
 - unit-тесты. Самый нижний уровень, "фундамент" пирамиды. Юнит-тесты, или модульные тесты - это покрытие тестами модулей проекта (функций, компонентов, классов, ...). Их больше всего, они все автоматизированы. И это входит в обязанности разработчика.
 - integration-тесты. Средний уровень пирамиды. Это взаимодействие между компонентами (например, API, сервисы, логи на сервере и БД, ...).
 - end-to-end тесты, то есть тесты всей системы в целом. Это имитация действия пользователей.

В рамках наших занятий, мы будем говорить в основном о юнит-тестах.

Фронтендерам в написании юнит-тестов помогают библиотеки. Например, библиотека `Jest`. В случае разработки приложения с использованием `create-react-app` библиотека `Jest` уже добавлена в зависимости проекта, и мы можем приступать к написанию тестов.

У нас ситуация иная, т.к. мы работаем с `Vite`. Здесь нам придется вручную установить необхдимые зависимости.
```
npm install --save-dev vitest
```

Эта команда добавит зависимость - библиотеку vitest, причем добавит ее в зависимости "для разработки" - то есть она не пойдет в итоговую продуктовую сборку.

И нам еще нужно добавить скрипт для запуска тестов: в файле `package.json` нам надо добавить в раздел `scripts` строку `"test": "vitest"`. То есть по итогу, наш блок scripts в package.json будет выглядеть так:

```
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "test": "vitest"
  },
```

И теперь мы можем запускать юнит тесты командой из терминала `npm test`.

### Что и как тестировать
Обычно, в react-проектах покрывают тестами:
 - js-модули (вспомогательные функции, которые написаны на чистом JS)
 - react-компоненты
 - кастомные хуки

### Что такое тест
Если максимально упрощенно: тест - это запуск того, что тестируется с заданными параметрами/аргументами, и сравнение полученного результата с ожидаемым. Условно говоря, мы вызываем функцию с конкретными параметрами, и ожидаем от нее определенный возвращенный результат. Или мы просим отрендерить компонент с определенными пропсами, и ожидаем получить определенную разметку.

### Анатомия юнит-теста (для Jest)
Тест (`test case`) обычно содержит название теста (краткое описание, что же он проверяет), и функцию, которая должна выполнить определенные проверки. Тесты могут определяться в "пакеты", т.н. `Test Suites`.

### Как заставить все работать
Нужно просто начать писать наши тесты. Есть **правило именования** файлов с тестами: `ИМЯ_ТЕСТИРУЕМОГО_ФАЙЛА.test.РАСШИРЕНИЕ_ФАЙЛА`.

Пример: мы тестируем функциональность, описанную в файле `MathUtils.js`. тогда нам нужно создать файл `MathUtils.test.js`, и в нем описывать наши тесты.

Тогда, при запуске процесса автотестирования, Jest / vitest пройдется по каталогам проекта, и сам "подхватит" нужные файлы (с расширением `*.test.*`). Он это воспримет как тесты, и выполнит их.

### Пишем первые юнит тесты
Начнем с тестирования утилитарных JS-функций. Наша задача - покрыть тестами утилиты из файла src/utils/mathUtils/mathUtils.js. Создадим рядом файл `mathUtils.test.js`. В нем напишем наш первый тест.

```
import { describe, test, expect } from 'vitest';

// test - это зарезервированное имя тест кейса, которое будет подхвачено Jest / vitest.
test(
  'First test which checks the "add" function', // первый аргумент - это описание тест кейса
  () => { // второй аргумент - функция с самим юнит тестом
    const addResult = add(2,2); // вызываем нашу функцию, записываем результат в переменную
    expect(addResult).toBe(4); // сравниваем результат вызова нашей функции с ожидаемым значением
  }
);
```

Теперь попробуем прикинуть нештатные случаи.
 - передано не число
 - передан NaN (который является number)

Покроем и эти случаи тестами.
```
// test - это зарезервированное имя тест кейса, которое будет подхвачено Jest / vitest.
test(
  'Second test for "add" function: passing not a number',
  () => {
    const addResult = add('3',2);
    expect(addResult).toBe('something went wrong!');

    const addResult2 = add(NaN, 1);
    expect(addResult).toBe('something went wrong!');
  }
);
```

Получившийся код работает, но будет лучше объединить все это в тест-сьют. Давайте так и сделаем. Для этого есть функция `describe`.
```
describe(
  'Test "add" function',
  () => {
    it('Check number+number', () => {
      const result = addResult(2,2);
      expect(result).toBe(4);
    });
    it('Check non-number argument', () => {
      const result = addResult('2', 2);
      expect(result).toBe(''something went wrong!');
    });
    it('Check NaN argument', () => {
      const result = addResult(NaN, 2);
      expect(result).toBe(''something went wrong!');
    });
  }
)
```

Таким образом, получается пакет тестов для одной функции. Можно это записать еще короче:
```
describe(
  'Test "add" function',
  () => {
    const testsData = [
      { name: 'Check number+number', arg1: 2, arg2: 2, expected: 4 },
      { name: 'Check non-number argument', arg1: '2', arg2: 2, expected: 'something went wrong!' },
      { name: 'Check NaN argument', arg1: NaN, arg2: 2, expected: 'something went wrong!' },

    ];
    testsData.forEach( ({ name, arg1, arg2, expected }) => {
      it( name, () => {
        const result = add(arg1, arg2);
        expect(result).toBe(expected);
      })
    });
  }
)
```

### Закрепление практикой
Аналогичным образом, покройте оставшуюся функциональность тестами. Особое внимание - на деление.

### Работа с не-примитивами
Jest / vitest - умные товарищи. Они могут "разумно" работать с объектами - то есть при сравнении объектов/массивов, сравнивать их содержимое. Для этого, есть метод `toEqual`.
```
import {describe, expect, it} from 'vitest';
describe(
  'Test "duplicate" function',
  () => {
    it( 'Check numbers duplication', () => {
      expect(duplicate([1,2,3])).toEqual([2,4,6]);
    });

    it( 'Check strings duplication', () => {
      expect(duplicate(['1','2','3'])).toEqual(['11','22','33']);
    });

    it( 'Check non-number and non-string args', () => {
      expect(duplicate([1,'2',true,{}])).toEqual([2, '22', null, null]);
    })
  }
);
```

Теперь напишите тест-сюьт для функции `getItemTypes`. Она принимает массив, и должна вернуть объект, который будет содержать кол-во свойств по типам (см.реализацию).


### Еще интересное по тест-кейсам
Тестовый фреймворк умеет не только сравнивать, его возможности гораздо шире. Например, он может зафиксировать количество вызовов функции, проверить с какими аргументами вызвана функция, может отследить, что брошено исключение, может формировать неравенства, и многое другое. Рассмотрим пример с количеством вызовов функции. В файле `complexUtils`, есть функция `chooseCallback`. Она принимает два колбэка, и флаг, который определяет, какой колбэк выполнять. Напишем юнит-тесты для этой функции.
```
import {describe, expect, it, vi} from 'vitest';

describe(
  'Test "chooseCallback" function',
  () => {
    it('Check first callback', () => {
      // Делаем т.н. "моки" - то есть липовые функции (заглушки)
      const firstCallback = vi.fn();
      const secondCallback = vi.fn();
      // вызываем нашу функцию, которую мы хотим протестировать
      chooseCallback(firstCallback, secondCallback, 'first');
      // проверяем, что первый колбэк был вызван хотя бы 1 раз
      expect(firstCallback).toBeCalled();
      // проверяем что второй колбэк не был вызван совсем
      expect(secondCallback).not.toBeCalled();
    });
  }
)
```

И для закрепления, покройте тестами `customForEach`.

## Полезные ссылки по занятию:
 - [Vitest + RTL](https://victorbruce82.medium.com/vitest-with-react-testing-library-in-react-created-with-vite-3552f0a9a19a) - неплохой старт, чтобы понять как все настроить, пока можно смотреть до момента работы с React Testing Library.
 - [Документация](https://vitest.dev/guide/) - англоязычная, не особо понятная, но все же документация. Рекомендуется использовать как справочник.