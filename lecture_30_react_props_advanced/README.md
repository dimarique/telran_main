# README

## Лекционное занятие №30

### Тема:

Репозитарий содержит материалы по лекционному занятию №30, посвященному продолжению знакомства с React.js, и понятию пропсов.

**Рендеринг списков в React**.
Очень часто, в React нам нужно отрисовать список чего-то (обычно это массив каких-то данных). Например, список товаров, данные о которых мы получим с бэка. Как нам это сделать, с учетом того, что в JSX мы не можем использовать стандартные циклы?

Для этого, есть специальный прием. Для рендеринга списка, нам нужно использовать метод `map` у массива - источника данных. И колбэк `map`-а будет определять, в какую разметку превратится элемент нашего массива.

```
const strings = ['Array', 'Of', 'Strings'];
// ...
return (
  <>
    <p>Simple List</p>
    {
      strings.map(str => {
        return <p key={str}>{str}</p>
      })
    }
  </p>
)
```

Здесь следует обратить внимание на несколько моментов.
 - такая штука работает только с методом `map`.
 - колбэк-функция возвращает разметку JSX, в которую должен превратиться элемент нашего массива.
 - контейнер (тег верхнего уровня) итоговой разметки должен обязательно содержать атрибут `key`, в который нужно записать уникальный идентификатор элемента. При этом, НЕ НУЖНО использовать в качестве ключа индекс элемента! Это делается для оптимизации производительности, при рендеринге больших списков.

**Закрепим практикой**
1. В файле `data/dwarwes.js`, есть массив с локациями, откуда ждут гостей на слет (массив `middleEarthAreas`). Нужно отрендерить этот массив в виде параграфов.
2. В файле `persons.js` есть массив с программой нашего слета (`programe`). Нужно отрендерить этапы программы в виде неупорядоченного списка (`ul`), под контейнером с именами организаторов слета.
3. В файле также содержится массив `detailed` с подробной информацией о некоторых гостях. В компоненте `App`, под программой слета, нужно отрендерить данные об этих гостях. Рендерим также в виде div-ов, где будет заголовок с именем и прозвищем, и параграф с темой доклада.

**Передача не-примитивов в пропсах**
Ранее, мы передавали в качестве пропсов в основном примитивы. Чаще всего, этого недостаточно - нам нужно передавать нечто более сложное по своей структуре. Например, массивы. Или объекты. Или еще что-нибудь.

Работы с такими пропсами ничем не отличаются от пропсов-примитивов - точно так же объявляем их в компоненте, и передаем при рендеринге. Основная разница в том, что при передаче таких пропсов мы должны их передавать как "динамику" - то есть оборачивать в фигурные скобки.

Рассмотрим пример. Ранее у нас был компонент `StyledParagraph`, который ожидал 2 пропса: текст и класс параграфа. Выглядел он так:
```
function StyledParagraph( { text, paragraphClass } ) {
  return (
    <p className={paragraphClass}>{text}</p>
  )
}

// ....

<SimpleParagraph text="Hello World!" paragraphClass="customClass">
```

Попробуем переписать его с использованием объекта для пропсов.
```
function StyledParagraph( { settings } ) {
  return (
    <p className={settings.paragraphClass}>{settings.text}</p>
  )
}

// ....

const paragraphOptions = {
  text: 'Hello World!',
  paragraphClass: 'customClass'
}

// ...

<StyledParagraph settings={paragraphOptions} />
```

То есть, мы передаем в компонент объект. Этот объект заходит в качестве пропса. И при передаче, нам нужно обернуть его в в фигурные скобки - чтобы React передал именно то, что нужно.

Можно создать объект на месте - через литерал объекта. Это работает так же, как мы раньше работали с инлайн-стилями (атрибут style).
```
<SimpleParagraph settings={ {text: 'Hello World!', paragraphClass: 'customClass' } } />
```

То есть, здесь мы создаем объект "на месте", и тут же его передаем в пропсах. Внешние фигурные скобки - мы обозначаем это как динамику, а внутренние - это литерал объекта, то бишь мы создаем новый объект, и его передаем в пропсы.

С массивами работает точно так же:
```
<SimlpeArray array={ [1,2,3,4,5] }>
```

**Закрепим практикой**
1. В компоненте `SimpleHeader`, добавьте проп `customStyles`, который будет принимать объект со свойтствами `fontSize`, `color` - для определения размера шрифта заголовка и цвета текста соответственно. Примените этот проп в компоненте, для задания инлайн-стилей заголовку.
2. У нас был создан компонент `DwarfCard`, который отвечал за отрисовку данных карточки гнома. Обычно, данные о гномах идут в виде объектов - поэтому, измените компонент так, чтобы он ожидал в пропсах объект `dwarfData`, у него будут свойства `name`, `weapon`.
3. Создаем компонент `DwarfList`, он должен принять в пропсах следующее:
 - текст для заголовка списка `listHeaderText` (рендерим как тег `h4`). Если пусто - используем строку `Dwarwes List`.
 - массив объектов с данными гномов `dwarwes`. Нужно отрендерить гномов в виде карточек (используем наш `DwarfCard`), внутри контейнера `div`.
4. Вспоминаем условный рендеринг. Если в компонент `DwarfList` в качестве пропа `dwarwes` передан пустой массив, или не передано ничего - компонент должен рендерить заголовок `h4` с текстом `Empty dwarwes list!`.
5. Немного усложним первую задачу. Измените компонент `SimpleHeader` так, чтобы он мог работать с объектом инлайн-стилей произвольной структуры. То есть, любые значения инлайн стилей могут быть в объекте `customStyles`.

**Обработка событий в компонентах**
Нам нужно уметь реагировать на события в компонентах. Ведь компоненты рисуют нам пользовательский интерфейс, и мы предполагаем, что пользователь будет как-то с ним взаимодействовать. Нажимать на кнопки, водить мышкой, что-то забивать в текстовые поля, и все такое. И вот для реакции на эти события, нам нужны обработчики.

Фактически, обработка событий в React-компонентах практически ничем не отличается от обработки событий в JS. Есть пара моментов, на которых стоит акцентировать внимание.
 - В React, все события оборачиваются в кроссбраузерную обертку - `SyntheticEvent`. На практике, это ничего не меняет в плане обработки, но знать об этом нужно.
 - Обработчики "вешаются" не так, как мы привыкли это делать. Здесь мы добавляем обработчики как атрибуты для React-элементов (обычных тегов). При этом, имена событий пишутся в camelCase: onClick, onChange, onBlur, ...

Рассмотрим пример. Предположим, мы хотим добавить слушатель событий на наш параграф, и просто выводить в консоль факт клика по параграфу.
```
function StyledParagraph( { settings } ) {

  // Объявляем функцию-обработчик (это ОБЫЧНАЯ ФУНКЦИЯ)
  const handleClick = (event) => {
    console.log('Clicked on paragraph!');
  }

  return (
    <p className={settings.paragraphClass} onClick={handleClick} >{settings.text}</p>
  )
}
```

В компоненте, мы объявляем функцию-обработчик. Эта функция будет вызываться при клике на параграф. В самом параграфе, мы используем атрибут `onClick`, который позволяет нам установить обработчик на событие клика. Подавляющее большинство событий в React имеет такие обработчики - префикс `on`, и название события с большой буквы.

**Закрепим практикой**
1. В компоненте `SimpleHeader`, добавьте обработчик события клика по заголовку. Нужно, чтобы при клике выводился в консоль текст заголовка.
2. В компоненте `DwarfCard`, добавьте кнопку с текстом `Describe`. На нее добавьте обработчик события клика, чтобы при клике мы бы выводили в консоль информацию о гноме вида "Гном ИМЯ_ГНОМА, владеет оружием ОРУЖИЕ_ГНОМА".
3. Создадим компонент `DwarfForm`, в котором потенциальный участник похода к Одинокой горе может заполнить заявку. Нужно чтобы форма рендерилась в виде контейнера, который будет включать в себя инпут для имени гнома, инпут для возраста, и инпут для оружия. Также, разместите кнопку. При клике на кнопку, нужно выводить в консоль текст "Заявка принята!". ВАЖНО: если в качестве контейнера будет использоваться тег `form`, то страница обновится после нажатия на кнопку - подумайте, как этого избежать.
4. Сделаем ограничение на длину имени - имя гнома не может быть больше 10 символов. Задача к обсуждению - как это сделать имеющимися средствами. Подсказка - нам нужно будет реагировать на событие инпута (вопрос, какое!).

**Передача функций в пропсах**
В пропсах можно передавать и функции. Зачем? Потому что иногда нам нужно передать в компонент какие-то обработчики, которые должны произойти по наступлении события в компоненте. Например, если у нас есть компонент, который рисует форму, и мы хотим при клике на кнопку отправки формы, выполнять еще что-то на уровне родительского компонента (скажем, менять фон всей страницы). В этом случае, мы можем передавать в пропсах функцию (колбэк), и вызывать ее уже внутри компонента тогда, когда сочтем нужным.

Пусть у нас есть задача, обрабатывать клики на параграфе. Тогда мы можем просто передать в компонент эту функцию в качестве пропса, и в нужный момент ее вызвать.
```
function StyledParagraph( { settings, clickHandler } ) {

  return (
    <p className={settings.paragraphClass} onClick={clickHandler} >{settings.text}</p>
  )
}
```

То есть, теперь наш компонент ожидает функцию, которая будет вызвана тогда, когда пользователь кликнет по параграфу. Осталось ее передать из вызывающего компонента.

```
function App() {

  const paragraphClickHandler = (event) => {
    console.log('Click happened!');
  }

  const paragraphSettings = {
    paragraphClass: 'customClass',
    text: 'Hey, click me!'
  }

  return (
    <StyledParagraph settings={pararaphSettings} clickHandler={paragraphClickHandler} />
  );
}
```

### Полезные ссылки
 - Описание [пропсов](https://react.dev/learn/passing-props-to-a-component) в документации React.
 - [Обработка событий](https://react.dev/learn/responding-to-events) в React.