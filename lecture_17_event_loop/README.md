 # README

## Лекционное занятие №17

### Тема:

Репозитарий содержит материалы по лекционному занятию №17, посвященному асинхронным операциям в JS, и Event Loop.

### Event Loop

Как мы уже рассмотрели ранее, JS является однопоточным языком. Тем не менее, мы говорим об асинхронном коде, который выполняется как-то иначе, чем синхронный (имитация параллельного выполнения). Попробуем разобраться, как это происходит.

Прежде всего, определим понятие "очередь". Очередь - это структура данных, организованная по принципу "FIFO - First In First Out", то есть первый пришел - первый ушел. Что это значит? Это значит, что события, которые складываются в очередь, обрабатываются в порядке поступления: сначала обрабатываем того, кто первым был добавлен в очередь, далее второго, и т.д.

Теперь, свяжем это понятие с нашим контекстом. В веб-приложениях, браузер постоянно выполняет какие-то задачи. Это создание и обработка событий, выполнение скриптов, реакция на действия пользователя, и т.д. Эти задачи выполняются браузером в порядке поступления, то есть в порядке очереди. Можно сравнить это со "списком дел", в который постоянно добавляются дела, и браузер постоянно это выполняет.  Это все - синхронный код, с которым мы уже знакомы. Он будет выполняться немедленно, без задержек, в порядке объявления команд.

Давайте разберемся с `setTimeout`, как же он работает. Как мы ранее говорили, если мы планируем какую-то задачу с использованием таймаута, то она будет выполнена асинхронно. Когда мы вызываем `setTimeout`, движок создает новую **макрозадачу**, и кладет ее в конец очереди **макрозадач**. Термин "макрозадача" - это термин из документации, не стоит в него особо вникать. Ключевой момент здесь - **очередь макрозадач**.

Рассмотрим на примере.
```
// очередь макрозадач пуста

console.log('First'); // синхронный код (1)

setTimeout( () => { // кладем задачу в конец очереди макрозадач
  console.log('timeout'); // (3)
}, 100);

console.log('Second'); // синхронный код (2)
```

Что же произойдет? Мы уже знаем, что сначала выполнится синхронный код (в порядке объявления команд) - то есть (1), затем (2). А дальше будет выполнена макрозадача (3). То есть будет вывод вида First - Second - timeout.

Если у нас будет несколько таймаутов, или интервал/несколько интервалов, то в очереди макрозадач будет та логика, которую они планируют, и выполняться она будет в порядке поступления.
```
// очередь макрозадач пуста

console.log('First'); // синхронный код (1)

setTimeout( () => { // кладем задачу в конец очереди макрозадач
  console.log('quick timeout'); // (3)
}, 100);
setTimeout( () => { // кладем задачу в конец очереди макрозадач
  console.log('longer timeout'); // (4)
}, 200);

console.log('Second'); // синхронный код (2)
```

Тут вывод будет First - Second - quick timeout - longer timeout. Потому что в очередь макрозадач сначала попадет первый таймаут (100мс), а затем второй (200мс).

И теперь пришла пора поговорить о промисах, пока что у нас только они остались неохваченными. Как же выполняются промисы? И кто будет выполнен первым: промис, или таймаут?

Для обработчиков промисов существует отдельная, специальная очередь. Потому что промисы именуются **микрозадачами**. Тоже мутный термин, вникать в него особо не надо - просто нужно понимать, что микро- и макро-задачи это разные вещи. И вот для микрозадач существует своя очередь. В нее события тоже поступают в порядке возникновения.

Осталось понять, каким образом осуществляется синхронизация между очередями, кто выполняется первее, и как.

И вот тут в дело вступает **событийный цикл**. Порядок обработки будет следующий:
1. Выполнить весь синхронный код.
2. Выполнить ВСЕ задачи из очереди **микрозадач** в порядке поступления.
3. Взять из очереди **макрозадач** самую старую, выполнить ее.
4. Перейти к шагу 2.

**ВАЖНО!** Это ОЧЕНЬ упрощенное понимание работы событийного цикла. К тому же, рассмотрены не все возможности работы с микрозадачами, например еще есть метод `queueMicrotask`. Поэтому желающие разобраться дополнительно приглашаются прочесть информацию из полезной ссылки.

**Закрепим практикой**
В задачах далее, нужно сказать, в какой последовательности мы увидим вывод в консоли.

1.
```
console.log('Start');

const myPromise = new Promise( (resolve, reject) => {
  resolve('Promise Result');
});
myPromise.then( res => console.log(res) );

console.log('Finish');

// Start - Finish - Promise Result
```

2.
```
console.log('Start');

const myPromise = new Promise( (resolve, reject) => {
  fetch(URL).then(res => res.json()).then(res => resolve(res))
});

setTimeout( () => console.log('Timeout'), 1000 );

myPromise.then(res => console.log(res) );

console.log('Finish');
```

3.
```
console.log('Start');

const myPromise = new Promise( (resolve, reject) => {
  resolve('Promise Result');
});
const secondPromise = new Promise( (resolve, reject) => {
  resolve('Second Promise Result');
});

setTimeout( () => console.log('Timeout'), 0 );

myPromise.then(res => console.log(res) );
secondPromise.then(res => console.log(res) );

console.log('Finish');
```

### Полезные ссылки
 - [Event Loop](https://learn.javascript.ru/event-loop) - обязательно к ознакомлению.