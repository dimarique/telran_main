# README

## Лекционное занятие №15

### Тема:

Репозитарий содержит материалы по лекционному занятию №15, посвященному работе с промисами.

**Вводная, мотивационная часть**
Прежде чем начать обсуждать промисы, нужно поговорить о параллельном выполнении задач. Что имеется в виду: выполнение нескольких задач одновременно. Зачем это нужно? Для того, чтобы оптимальным образом использовать вычислительные ресурсы, а заодно не бесить пользователя. Вот например, наверняка все имеют опыт работы с банковскими приложениями. Вы заходите в приложение, где-то наверху вертится полоска загрузки (грузим информацию о ваших остатках из процессинга), но интерфейс уже доступен, не блокирован, и вы можете с ним работать. То есть, загрузка информации об остатках выполняется ПАРАЛЛЕЛЬНО отображению интерфейса.

В многопоточных языках программирования (Java, C, и многие другие), такое реализовано за счет использования потоков и процессов, использования ядер процессора и т.д. Там есть много нюансов, и это очень мощная штука. Но JS всего этого лишен (к сожалению, или к счастью). Потому что JS является ОДНОПОТОЧНЫМ языком. Все задачи выполняются в одном потоке, последовательно.

Однако, в JS есть понятие синхронного и асинхронного кода.
 - Синхронный код - это то, с чем мы привыкли работать, то есть команды выполняются последовательно, одна за другой, и выполняются немедленно.
 - Асинхронный код - это задачи, которые выполняются не прямо сейчас, а потом. То есть, выполнение задачи требует некого количества времени, и это количество мы не знаем - оно от нас не зависит.

Что это значит? Давайте рассмотрим, например, задачу загрузки чего-то с сервера (пусть это будет список товаров). Клиентская сторона отправляет запрос "эй сервер, дай мне список товаров", и хочет их отрисовать на странице. И клиентская сторона не знает, когда конкретно придет ответ - то ли спустя одну секунду, то ли спустя минуту - потому что это зависит от скорости работы сервера, от его загрузки в данный момент, от скорости соединения, и многого другого. То есть, задача отрисовки результатов (собственно списка товаров), должна быть выполнена не прямо сейчас, а тогда, когда мы получим ответ от сервера. Это называется асинхронной задачей - то есть, нам нужно дождаться ответа от сервера, и как-то обработать результат.

**Немного истории - как было до промисов**
Окунемся в историю JS и рассмотрим, как это было до промисов. Тогда во всем этом нам помогали колбэки - то есть, функции обратного вызова. Мы вызывали функцию отправки сетевого запроса (она доступна из коробки), и в нее передавали аргументом функцию-колбэк, которая должна была быть вызвана в момент получения ответа.ь То есть мы как бы говорили "обратись к серверу, и когда получишь ответ - вызови функцию-колбэк". Так решались все асинхронные задачи.

Казалось бы, а зачем нам какие-то промисы, зачем изобретать нечто, когда вот оно, все работает? Вроде и верно, но дьявол в деталях. Проблема появлялась тогда, когда нам нужно было выполнить несколько асинхронных действий, одно за другим. Ну например, отправить несколько запросов, и дождаться выполнения всех запросов. Или отправить запрос, потом разобрать результат (тоже асинхронная операция), отправить другой запрос на основе результатов первого, и снова разобрать результат. Получалась очень неизящная картина:

```
sendFirstRequest( function successCallback(response) {
   const parsedResult = parseResult(response, function secondCallback(res) {
      sendSecondRequest(res, function successSecondCallback(response) {
         ...
      })
   })
})
```

То есть мы получали эдакую "лестницу" из колбэков. Такая проблема называется `callback hell`. И вот для решения этой проблемы были придуманы промисы.

**Все, что вы хотели знать о промисах, но боялись спросить**
Итак, после того, как мы разобрались с тем, что такое асинхронный код, и рассмотрели то, как с ним работали ранее, пришла пора поговорить о промисах. Начнем мы с того, что разберем само понятие промиса.

**Promise (промис)** можно рассматривать как обещание от JS сделать что-то в будущем. В отличие от обещаний в реальном мире, JS товарищ обязательный, и все, что он нам пообещает, будет выполнено. На выполнение этого действия, требуется время. То есть, мы создаем обещание, что в ближайшем будущем наш асинхронный код выполнится, и вернет результат. И промис дает нам удобный (на фоне колбэков) инструмент для работы с этим результатом.

Что от нас ожидает промис? Он ожидает от нас функцию-исполнителя, то есть функцию, которая будет выполнять какую-то задачу, при этом выполнение этой задачи может занять произвольное время. Но это функция непростая. Она принимает 2 аргумента - первый для успешного (штатного) завершения промиса, а второй - для нештатного (то есть, что-то пошло не так).

Пока что ничего не понятно. Давайте попробуем на примере. Предположим, у нас есть следующий асинхронный блок:
```
const random = Math.random();
setTimeout( () => {
   return 'Here is a result!';
}, random * 1000);
```

Как мы можем получить доступ к результату работы функции, которая выполняется асинхронно? Или как мы можем выполнить что-то только ПОСЛЕ того, как запустится логика из таймаута? Спойлер: никак.

А вот промисы нам могут помочь решить эту задачу. Попробуем написать промис, который спустя случайное время вернет нам какой-то результат.

```
const myPromise = new Promise( function(resolve) {
   const random = Math.random();
   setTimeout( () => {
      resolve('Here is a result!'); // основная магия здесь - мы уведомляем того, кто ожидает завершения работы промиса
   }, random * 1000);
});
```

Такая запись нам поможет в решении проблем, описанных ранее. Здесь мы создаем промис через `new Promise`. Он ожидает от нас один аргумент: специальную функцию, которая будет выполнять задачу. Эта функция в первом аргументе принимает ДРУГУЮ ФУНКЦИЮ, которая должна быть вызвана тогда, когда задача выполнена - то есть, мы хотим как-то уведомить кого-то в вызывающем коде о том, что выполняемая задача успешно завершена. То есть, мы частично решили проблему, как мы можем выполнить что-то тогда, когда выполнится задача.

Теперь решим и остальные проблемы: как поработать с результатом выполнения задачи. Для этого, мы должны добавить на наш промис обработчик результата (иногда говорят, подписчика или слушателя). Для этого также есть специальная конструкция.
```
myPromise.then( function(successResult) {
   console.log('The result of promise is: ', successResult);
});
```

Обратите внимание, как мы добавляем обработчик результата промиса - через `then`. Этот `then` как бы говорит "я дождусь, пока мой промис `myPromise` успешно завершит свое выполнение, тогда запущу свою функцию, и передам ей в аргументе результат успешной работы промиса".

**ВАЖНО!** Стоит дополнительно акцентировать внимание на то, что в `successResult` в `then`-е будет передано то, что БЫЛО ПЕРЕДАНО в аргумент `resolve` в самом промисе. То есть, грубо говоря, то, чем мы зарезолвили промис - то будет передано в обработчик успешного завершения промиса.

**ТОЖЕ ВАЖНО!** Это правильный путь работы с промисами!

Можно попробовать прикинуть еще аналогию. На склад прибывает машина под разгрузку. Водитель не знает, сколько времени займет разгрузка, поэтому он говорит завскладом: "друже, на тебе мой номер телефона, как закончите разгрузку и подготовите накладную - набери". И уходит выполнять какие-то другие задачи (например, курить). Завскладом разгружает машину, и когда разгрузка закончена, а накладная подготовлена - набирает водилу. Тот приходит, забирает накладную, и уезжает.

```
const storePromise = new Promise( function(resolve) {
   // ... идет разгрузка машины
   // ... разгрузка успешно завершена
   const paper = "Important paper!"; // создаем накладную
   resolve(paper); // завскладом звонит водиле, и отдает ему накладную
}).then( function(preparedPaper) { // водила дождался звонка и накладной
   putPaperIntoWallet(); // водила убрал накладную
   driveAvay(); // водила уезжает со склада
});
```

**Закрепим практикой**
1. Пишем первый промис. Он должен быть успешно завершен числом 345.
2. Пишем промис, который должен быть успешно завершен числом 106 через 2 секунды после запуска (т.е. надо завершить промис спустя 2 секунды).
3. Пишем промис, который должен быть успешно завершен объектом со свойствами name = Vasya, age = 21, через 3 секунды после запуска.

**Нештатные ситуации**
Промисы не всегда завершаются успехом. Иногда, в процессе выполнения промиса, может произойти нечто неожиданное, и мы с этим справиться не можем. Например, мы отправили сетевой запрос, а сервер его не понял, и ответил нам чем-то непонятным. Или, возвращаясь к нашей аналогии с машиной, завскладом обнаружил бракованный товар, и он не готов его принять. Водиле все равно нужно уехать, но накладную он не получит - вместо этого он получит расписку от завскладом.

Промисы предоставляют нам инструмент и для этого. Это второй аргумент колбэка промиса (раньше был один - `resolve`, который мы вызывали при успехе). Теперь добавляется еще один - `reject`, который мы будем вызывать в случае нештатных ситуаций.

```
const storePromise = new Promise( function(resolve, reject) { // добавился второй аргумент
   // ... идет разгрузка машины
   // ... нашли брак
   const badPaper = new Error("Bad products!"); // создаем расписку по стандартной форме от завскладом
   reject(badPaper); // завскладом звонит водиле, и отдает ему расписку
}).then( function(preparedPaper) { // это не будет выполнено, потому что склад не принял товар, и промис не завершен успешно
}).catch( function(badPaper) { // водила получил расписку от завскладом
   handleBadPaper(badPaper); // водила кладет расписку в папку с документами
   driveAvay(); // уезжает
});
```

То есть, теперь у нас появилась возможность рассмотреть нештатную ситуацию. Если что-то пошло не так во время выполнения промиса - мы вызовем колбэк `reject`, а в аргумент ему передадим то, что может помочь вызывающему коду обработать нештатную ситуацию. В случае с сетевым запросом - например, сообщение об ошибке, которое мы покажем пользователю.

**Закрепим практикой**
1. Написать промис, который будет завершен ошибкой. В тексте ошибки укажите "Insufficient privilegies".
2. Написать промис, которы будет завершен ошибкой с текстом "Something went wrong!" спустя 2 секунды после запуска. Обработчик результата должен вывести его в консоль.

**Состояния промисов**
В JS, промис может находиться в одном из трех состояний:
 - pending - это значит что задача выполняется
 - fulfilled - задача успешно выполнена
 - rejected - во время выполнения что-то пошло не так

Сразу же при создании промиса, он получает состояние `pending`. Из него он может перейти или в состояние `fulfilled`, или в состояние `rejected`. После этого он не может изменять свое состояние - то есть, запустить промис по новой мы не можем, нужно создавать новый.

**Обработчик finally**
Есть еще важный момент, который следует упомянуть. Иногда, нам нужно выполнить некоторую логику после промиса вне зависимости от его результата. То есть, нам неважно, он выполнился успешно или нет - нам нужно просто дождаться завершения промиса, и выполнить логику. Для этого существует блок `finally`. Опять же, возвращаясь к складу - водитель вне зависимости от получения накладной или расписки о плохом товаре, уедет. То есть действие "отъезд машины" выполнится в любом случае. Но только после того как разгрузка будет успешно завершена, или же после того, как обнаружится брак.

```
const storePromise = new Promise( function(resolve, reject) {
   // ... идет разгрузка машины
   if (hasBadProducts) { // если есть плохие товары
      // готовим расписку
      const badPaper = new Error("Bad products!");
      // завскладом звонит водиле и вручает ему расписку
      reject(badPaper);
   }
   else { // плохих товаров нет, все в порядке
      // готовим накладную
      const goodPaper = 'Good paper!';
      // завскладом звонит водиле и вручает накладную
      resolve(goodPaper);
   }
}).then( function(goodPaper) {
   // все хорошо, складываем накладную в бумажник
   putIntoWallet(goodPaper);
}).catch( function(badPaper) {
   // что-то не так, кладем расписку в папку с документами
   handleBadPaper(badPaper); // водила кладет расписку в папку с документами
}).finally(() { // вне зависимости от результата, машина уедет со склада
   driveAvay();
});
```

**Закрепим комплексно практикой**
1. Напишем промис, который будет случайным образом завершаться успешно или неуспешно. В промисе, нужно взять случайное значение (используем `Math.random()`). Если это значение больше либо равно 0.5 - завершаем промис успехом, текстом `Success`. Если меньше 0.5 - то завершаем ошибкой, с текстом `Error`.
2. Написать промис, который через 2 секунды будет успешно завершен текстом "Successfully finished!". Этот текст нужно вывести в консоль.
3. Теперь задача через 2 секунды завершить промис "неуспехом", с текстом "Something went wrong!", и вывести результат в консоль.
4. Обеспечить вывод в консоль текста "Will appear in all cases" после завершения/отвержения промиса (т.е. в любом случае).
5. В скрипте есть функция `asyncFunction`. Изначально задумывалось, что она вернет строку через одну секунду после вызова. Но что-то пошло не так.. Перепишите функцию, чтобы она возвращала значение через одну секунду после вызова, и чтобы этим результатом можно было бы воспользоваться. Задача к обсуждению.


### Полезные ссылки
 - [Раздел про промисы](https://learn.javascript.ru/async) - это раздел учебника, посвященный промисам. Также настоятельно рекомендуется к прочтению - по этой теме стопроцентно будут вопросы на собеседованиях.