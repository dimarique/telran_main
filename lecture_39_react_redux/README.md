# README

## Лекционное занятие №39

### Тема:

Репозитарий содержит материалы по занятию, посвященному работе с библиотекой `Redux`.

### Цели занятия
- повторение и закрепление знаний;
- решение задач.

### Что предполагается рассмотреть
На сегодняшнем занятии, предполагается рассмотреть работу с библиотекой управления состоянием приложения, а также связанные понятия.

### Состояние приложения
Для начала, давайте поймем, какую проблему мы хотим решить. Мы пишем большое приложение, со множеством компонентов. Некоторым компонентам нужно как-то обмениваться данными (разделить между собой какие-то данные). И какие-то компоненты должны перерисовываться, если что-то из этих данных поменяется. Какие варианты решения этой проблемы мы уже знаем?
 - поднятие состояния
 - использование контекста

Оба варианта имеют свои "за" и "против". А сегодня мы рассмотрим еще один вариант. Этот вариант предполагает создание состояния всего приложения в целом. В этом "большом" состоянии мы будем хранить то, что мы хотим разделить между компонентами нашего приложения. И с помощью специальных инструментов, мы будем передавать нужные фрагменты этого состояния в компоненты-потребители. У нас также будет инструмент для того, чтобы сказать нашему приложению перейти в новое состояние, что повлечет за собой перерисовку компонентов-потребителей.

Вся эта "кухня" называется "однонаправленный поток данных". Почему однонаправленный? Потому что данные идут в одном направлении:
1. Компонент получает данные из состояния.
2. С помощью специального инструмента, компонент может сообщить, что нужно перейти в новое состояние.
3. Фрагменты нового состояния передаются в те компоненты, которые в этом нуждаются.

Таким образом, данные идут в ОДНОМ направлении.

**Как это работает**
Теперь, попробуем разобраться с тем, как это работает.

По сути, любое состояние `state` (неважно - приложения, компонента) - есть нечто структурированное. Например, это большой объект, который хранит в себе данные о разных фрагментах нашего приложения, которые нужны на разных уровнях иерархии компонентов. Предположим, у нас приложение - интернет-магазин. Мы при заходе на главную страницу, запрашиваем список этих товаров, и добавляем их в это состояние (скажем, как свойство `products`). А затем, берем эти товары из состояния в тех местах, где нам это реально нужно.

Где это хранится? В этом нам помогут те библиотеки, которые мы сегодня планируем рассмотреть: `redux`, `react-redux`. Давайте пока считать, что это состояние хранится в хранилище (`store`), которое представляет из себя некий "сейф". Мы можем с помощью специального инструмента достать оттуда то, что там хранится. Но просто так положить туда что-то нельзя, нам нужно использовать другой специальный инструмент. Точно так же, нельзя просто поменять что-то, что хранится в этом сейфе (как вы уже догадались, и для этого есть инструмент).

То есть, у нас уже вводятся как минимум два новых термина: хранилище (`store`), и состояние (`state`). Для создания этого, библиотеки дают нам определенные возможности.

Теперь разберемся с инструментарием. Разумеется, о каждом из них мы поговорим подробнее. У нас есть такие инструменты:
 - получение из хранилища фрагмента состояния. Этот инструмент нужен, когда мы хотим, чтобы наш компонент отслеживал изменение какого-то фрагмента (части) состояния, и при изменении этого фрагмента перерисовывался бы.
 - инициирование перехода приложения в новое состояние. А здесь, мы уже хотим сказать, что в нашем приложении что-то поменялось, старое состояние должно перейти в новое состояние, и заинтересованные компоненты должны перерисоваться.

Разберем подробнее, как приложение понимает, что ему нужно перейти в другое состояние. Все эти изменения инициируются компонентами. То есть, в компоненте что-то произошло, и компонент уведомил хранилище, что приложение должно перейти в новое состояние. Пока все норм, но откуда должно взяться новое состояние? Как хранилище поймет, что при наступлении одного события должно быть новое состояние А, а при наступлении другого - состояние Б? И тут появляются еще два новых термина: экшн (`action`), и редьюсер (`reducer`).

Экшн - это просто объект, который содержит свойство `type` (чтобы отличать разные экшны друг от друга), и ту информацию, которая нужна для определения нового состояния на основе старого. Например, мы загрузили с бэка список товаров, и хотим добавить его в состояние - тогда мы этот список товаров положим в наш экшн. То есть по сути, экшн - это просто "транспортный объект", его задача - донести до редьюсера информацию о том, что инициирован переход в новое состояние.

Редьюсер - это ЧИСТАЯ (!) функция, которая занимается тем, что принимает текущее состояние и экшн, смотрит на это, и делает нам новое состояние на основе старого, и на основе данных из экшна. Задача редьюсера - вернуть новое состояние. В зависимости от типа экшна, редьюсер понимает, как ему обработать его.

**Разберем на примере**
ВАЖНО! Мы сейчас разбираем основы работы редакса. Есть надстройка над ним, которая облегчает эту работу, мы разберем ее позже, но для понимания основ, мы проходим весь путь "с нуля".

Разбирать будем на примере максимально простого счетчика кликов. У нас будет компонет `Counter`, который будет рендерить счетчик. Будут кнопки "увеличить на 1", "уменьшить на 1".

Мы понимаем, что с учетом постановки задачи, нам нужно будет хранить в нашем состоянии только значение счетчика. Пусть так и будет. Также, из постановки следует, что у нас будет как минимум 2 инициатора перехода в новое состояние.

1. Начнем с создания структуры каталогов. Создадим в проекте папку `redux`, в которой будет лежать все, что нужно для состояния нашего приложения. И начнем с самого простого - с создания объектов-экшнов. То есть, тех самых "транспортных" объектов. Создадим папку `actions`, в которой будем хранить все, что касается эшкнов.
2. В этой папке, создаем файл `counterActions.js`, зесь мы будем держать те экшны, которые связаны с нашим счетчиком. Впоследствии, наше приложение будет расти, состояние будет усложняться, и мы будем создавать файлы для экшнов, связанных с другими фрагментами состояния. Но пока что, нам нужен только этот фрагмент.
```
// src/redux/actions/counterActions.js

export const COUNTER_ACTIONS = {
  increment: 'COUNTER/INCREMENT',
  decrement: 'COUNTER/DECREMENT',
}

export const incrementAction = () => {
  return { type: COUNTER_ACTIONS.increment }
}

export const decrementAction = () => {
  return { type: COUNTER_ACTIONS.decrement }
}
```

Файл содержит не только экшны, но еще и объект-"справочник", в котором перечислены возможные типы экшнов. Это необязательно, но упрощает написание кода в будущем - у нас есть одно место, где перечислены все возможные экшны, связанные со счетчиком.

Далее, у нас идут 2 функции. Это так называемые `action creator`-ы, то есть "создатели экшнов". Их задача - создавать объекты экшнов. В принципе, можно обойтись и без них, и создавать такие объекты "на лету", но так код выглядит чище.

3. Создаем редьюсер - то есть, нечто, что будет создавать новое состояние на основе предыдущего, и на основе полученного экшна. Для этого, создадим папку `reducers`, и в ней `counterReducer.js`.
```
// src/redux/reducers/counterReducer.js
import { COUNTER_ACTIONS } from "../actions/counterActions.js";

// начальное состояние
const initialState = 0;

export const counterReducer = ( state = initialState, action ) => {

  switch (action.type) {
    case COUNTER_ACTIONS.increment: {
      return state + 1;
    }
    case COUNTER_ACTIONS.decrement: {
      return state - 1;
    }
    default: return state;
  }
}
```

У нас создан редьюсер, который может управлять состоянием нашего счетчика: увеличивать его на 1, или уменьшать на 1. Редьюсер будет принимать текущее состояние, и объект экшна. Далее, редьюсер смотрит на тип экшна, и в зависимости от него он делает нам новый стейт.

4. Создаем хранилище. Для этого, нам понадобится инструментарий из библиотек. Создадим в папке `redux` файл `store.js`, который будет отвечать за создание стора.
```
// src/redux/store.js

import { createStore, combineReducers } from 'redux';
import { counterReducer } from './reducers/counterReducer';

export const store = createStore(
  combineReducers({
    counter: counterReducer
  })
);
```

То есть, мы создали хранилище, и положили в него фрагмент (их также называют срезами/слайсами) состояния. Пока что наше состояние состоит только из одного фрагмента - это фрагмент, отвечающий за состояние нашего счетчика. Мы положили его в свойство `counter` нашего объекта состояния, и за управление этим значением теперь отвечает наш `counterReducer`.

Осталось обернуть наше приложение в провайдер состояния.
```
// index.js
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App.js';
import { BrowserRouter } from 'react-router';
import { Provider } from 'react-redux';
import { store } from './redux/store.js';

const root = ReactDOM.createRoot(document.getElementById('root'));

root.render(
  <BrowserRouter>
    <Provider store={store}>
      <App />
    </Provider>
  </BrowserRouter>
);

```

5. Попробуем воспользоваться нашим стейтом. Создадим компонент для счетчика:
```
// src/components/Counter.jsx

export default function Counter() {

  return (
    <div>
      <p>Now counter is:</p>
      <button>Increment</button>
      <button>Decrement</button>
    </div>
  )
}
```

Теперь нам нужно сказать, что этот компонент должен использовать наш фрагмент состояния. В этом нам помогает хук `useSelector`, который определяет, какой именно кусочек стейта будет отслеживать именно этот компонент.
```
const counter = useSelector( state => state.counter );
```

Этот хук принимает функцию-колбэк, в которую в момент вызова будет передан весь стейт нашего приложения, и ее задача - выбрать тот кусочек, который нужен нашему компоненту.

6. Уведомляем приложение о том, что ему надо перейти в новое состояние. Для этого, у нас тоже есть специальный инструмент, имя ему `dispatch`. Мы должны "задиспатчить" наш экшн, то есть отправить экшн специальным путем, чтобы он точно попал в наш редьюсер, и повлек переход в новое состояние. И здесь нам также помогает хук, `useDispatch`. Он нам вернет просто функцию, которую мы должны вызвать тогда, когда захотим инициировать переход в новое состояние, и передать ей объект-экшн.
Целиком:
```
// src/components/Counter.jsx

import { useSelector, useDispatch } from 'react-redux';
import { incrementAction, decrementAction } from '../redux/actions/counterActions.js';

export default function Counter() {

  const counter = useSelector( state => state.counter );
  const dispatch = useDispatch();

  return (
    <div>
      <p>Now counter is: {counter}</p>
      <button onClick={() => dispatch(incrementAction())}>Increment</button>
      <button onClick={() => dispatch(decrementAction())}>Decrement</button>
    </div>
  )
}
```

Вот и весь компонент! Теперь он "подписан" на тот фрагмент стейта, который отвечает за счетчик, и будет перерисовываться каждый раз, когда этот фрагмент стейта будет изменяться. И также, он может инициировать изменение этого фрагмента (то есть переход в новое состояние), за счет того, что он "диспатчит экшны".

Разумеется, такой подход применим для всего, что мы хотим хранить в состоянии. И обычно состояние приложения гораздо сложнее в плане структуры, там будет большой объект с уровнями вложенности, массивами, и т.д.

**Закрепим практикой**
1. Добавьте кнопку в наш компонент-счетчик, который будет увеличивать значение счетчика в состоянии на 2. Для этого, нам понадобится:
 - определить новый тип экшна
 - определить новый action-creator
 - добавить обработку этого экшна в редьюсер
2. Делаем экшны с полезной нагрузкой. Добавим в наш компонент-счетчик инпут, в котором мы будем вводить какое-то число. Также нужно добавить кнопку. При нажатии на нее, нужно увеличить значение счетчика на то число, которое введено в инпуте. Если там ничего не введено - ничего не делаем.
3. Добавьте кнопку, которая будет уменьшать значение счетчика на число, введенное в инпуте.
4. Попробуем разделить состояние между компонентами. Создадим новый компонент, `CounterHelper.jsx`. Он должен содержать только параграф с текстом "Value from counter: ___", и добавлять вместо прочерка значение счетчика из редакс-состояния.


### Полезные ссылки
[Redux](https://dev.to/efkumah/how-to-manage-state-in-a-react-app-using-redux-5pc) - хорошее описание логики работы редакса, основных понятий, и многого другого.