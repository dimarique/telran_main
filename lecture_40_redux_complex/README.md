# README

## Лекционное занятие №40

### Тема:

Репозитарий содержит материалы по занятию, посвященному работе с библиотекой `Redux`, и работе с более сложным состоянием и несколькими редьюсерами.

### Цели занятия
- повторение и закрепление знаний;
- решение задач.

### Что предполагается рассмотреть
На сегодняшнем занятии, предполагается продолжить работу с библиотекой управления состоянием, рассмотреть работу с хранением не-примитивов в редакс-состоянии, и работу с несколькими редьюсерами.

### Хранение непримитивов
Пока что, мы хранили в состоянии только примитивный объект (число со значением счетчика). Обычно, в стейте хранится нечто более интересное - массивы, объекты, и т.д. Попробуем это реализовать.

Давайте начнем с простого. Предположим, мы пишем очередное приложение для списка дел. Сам список дел мы хотим хранить в массиве, в редакс-стейте. У нас будет компонент, который будет рисовать список дел (в виде параграфов), и будет компонент `AddTodo`, который будет содержать инпут и кнопку. При нажатии на кнопку, значение инпута будет добавляться в список дел.

Фрагмент состояния, в котором мы будем хранить список дел, не имеет никакого отношения к фрагменту состояния счетчика - а значит, имеет смысл их разделить. То есть, это будут два разных фрагмента одного состояния. А значит, нам нужно определить:
- новые экшны и action-creator-ы
- новый редьюсер
- добавить этот редьюсер в общее состояние

Начнем с создания экшнов.
```
// src/redux/actions/todoActions.js

export const TODO_ACTIONS = {
  ADD_TODO: 'TODOS/ADD_TODO'
}

export const addTodo = (todo) => {
  return {
    type: TODO_ACTIONS.ADD_TODO,
    payload: todo
  }
}
```

Следующий шаг - определение редьюсера.
```
// src/redux/reducers/todoReducer.js
import { TODO_ACTIONS } from "../actions/todoActions.js";

// начальное состояние - пустой массив, то есть никаких дел нет
const initialState = [];

export const todoReducer = ( state = initialState, action ) => {

  switch (action.type) {
    case TODO_ACTIONS.ADD_TODO: {
      return [...state, action.payload]
    }
    default: return state;
  }
}
```

Мы видим, что в редьюсере мы обрабатываем экшн добавления дела. Этот экшн обрабатывается так: мы создаем новый массив дел, в который войдут все элементы старого, и также добавится название дела, которое зашло в свойстве `payload` нашего экшна. Очень важно, при использовании "чистого" редакса (без надстроек типа `redux/toolkit`, о котором поговорим позже), контролировать тот факт, что новый стейт НЕ МУТИРУЕТ старый, а именно создает новый. Иначе будет работать некорректно (можно поэкспериментировать).

Теперь, нам нужно добавить этот фрагмент стейта, создаваемый редьюсером, в общий стейт.
```
// src/redux/store.js

import { createStore, combineReducers } from 'redux';
import { counterReducer } from './reducers/counterReducer';
import { todoReducer } from './reducers/todoReducer';

export const store = createStore(
  combineReducers({
    counter: counterReducer,
    todos:   todoReducer
  })
);
```

Мы видим, что мы добавили в наш стейт новый фрагмент: назвали его `todos`, и в него мы сложили то, что нам будет возвращать наш `todoReducer`.

И теперь, создадим компоненты, которые будут работать с нашим состоянием.
```
// src/components/todos/AddTodo.jsx
import {useState} from 'react';
import { addTodo } from '../../redux/actions/todoActions.js';
import { useDispatch } from 'react-redux';

export default function AddTodo() {

  const [todo, setTodo] = useState('');

  const handleTodoChange = (e) => {
    setTodo(e.target.value);
  }

  const dispatch = useDispatch();

  const btnClickHandler = () => {
    if (todo) dispatch(addTodo(todo));
  }

  return (
    <div>
      <input type='text' placeholder='Todo name' value={todo} onChange={handleTodoChange}/>
      <button onClick={btnClickHandler}>Add Todo</button>
    </div>
  )
}
```

А это - компонент отрисовки дел.

```
// src/components/todos/TodoList.jsx
import { useSelector } from 'react-redux';

export default function TodoList() {

  const todos = useSelector( state => state.todos );

  return (
    <div>
      {todos.map(el => <p key={el}>{el}</p>)}
    </div>
  )
}
```

Теперь у нас есть фрагмент стейта, который содержит массив.

С объектами, это работает точно так же. Давайте попробуем теперь усложнить наш фрагмент стейта, отвечающий за список дел. Теперь мы хотим хранить не только сам список (массив с делами), но и например количество дел. То есть, во фрагменте состояния, кроме массива с делами, будет еще примитивное значение. И теперь получается, что этот наш фрагмент состояния должен иметь составную структуру. Давайте теперь будем хранить там объект, у которого будет свойство `todos`, содержащее массив с делами, и свойство `count`, содержащее количество дел. Для этого, нам нужно будет перестроить наш редьюсер.

```
// src/redux/reducers/todoReducer.js
import { TODO_ACTIONS } from "../actions/todoActions.js";

// начальное состояние - объект, который содержит пустой массив дел, и свойство count = 0
const initialState = {
  todos: [],
  count: 0
};

export const todoReducer = ( state = initialState, action ) => {

  switch (action.type) {
    case TODO_ACTIONS.ADD_TODO: {
      return {
        todos: [...state.todos, action.todo],
        count: state.count + 1
      }
    }
    default: return state;
  }
}
```

Таким образом, теперь наш редьюсер работает немного иначе. Обратите внимание - мы НЕ МУТИРУЕМ старое состояние, мы создаем НОВОЕ на основе старого. То есть у нас будет новый ОБЪЕКТ, внутри которого будет лежать новый массив.

**Закрепим практикой**
1. Делаем компонент `ColorPicker`, он должен давать возможность подбора цвета. Суть компонента - пользователь имеет возможность с помощью трех компонентов-ползунков указать 3 числа от 0 до 255. Для отрисовки ползунков, используем конструкцию:
```
<input type="range" min="0" max="255" id="colorId"/>
```

Значения из ползунков храним в редакс-стейте, для этого нам нужно будет создать фрагмент стейта `color`. В нем будем хранить объект со свойствами `red`, `green`, `blue`.
2. Используем наш цвет из редакс-стейта, создаем компонент `ColorDemo`. Он должен показывать выбранный цвет в виде квадрата 50 на 50 пикселей, заданного цвета. Для указания фона, можно использовать конструкцию:
```
function rgb(r, g, b){
  return "rgb("+r+","+g+","+b+")";
}
```


### Полезные ссылки
[Redux](https://dev.to/efkumah/how-to-manage-state-in-a-react-app-using-redux-5pc) - хорошее описание логики работы редакса, основных понятий, и многого другого.