# README

## Лекционное занятие №3

### Тема:

Репозитарий содержит материалы по лекционному занятию №3, посвященному работе с адаптивной версткой и медиазапросами.

### CSS Adaptive
Давным-давно, на заре интернета, сайты делались только для больших экранов - для компьютеров. Но с тех пор прошло много времени, наука и техника шагнули вперед, появились ноутбуки, планшеты, смартфоны, и разработчикам сайтов добавилось головной боли. Теперь мало просто сверстать сайт - нужно еще и сделать его так, чтобы он нормально отображался на разных экранах. И вот здесь и кроется основная проблема, как же это обеспечить? С учетом наличия дикого количества разнообразных китайских устройств без единого стандарта по размеру экранов.

Чтобы решить эту проблему, нужно было переходить к такому подходу в верстке, который гарантировал был нормальную (ну или около-нормальную) работу на большинстве возможных вариантов экранов. То есть делать отзывчивые (responsive) веб-проекты, которые могли бы по-разному отображаться на разных экранах. Изначально, вообще говоря, писались отдельные версии специально для мобильных - наверное, помните такое. Но это усложняет разработку, и увеличивает стоимость. Поэтому, чтобы обеспечить работу с отзывчивыми и адаптивными макетами, были придуманы медиа-запросы в CSS.

Кстати говоря, флексы и гриды, которые мы рассматривали ранее, также внесли свою посильную лепту в разработку отзывчивых, гибких макетов.

Итак, что же такое отзывчивые макеты, и за счет чего их делать? Это макеты, которые "подстраиваются" под размер экрана пользователя. То есть, будут по-разному отображаться на разных экранах. Например, на больших экранах мы будем изображать список товаров интернет-магазина в виде таблицы из 5 столбцов. На планшетах - из 4. На больших смартфонах - 2 столбца, и на всех остальных - один столбец. Звучит здорово - осталось понять, как нам это сделать.

Здесь нам на помощь приходят медиа-запросы. То есть, мы явно говорим нашему макету списка товаров, что при каких-то условиях (например, при ширине экрана меньше 375 пикселей), он должен отображаться в один столбец. При ширине 376-520 пикселей - мы считаем это большим смартфоном, и рендерим список товаров в 2 столбца. И так далее.

Вопрос: почему именно такие цифры? Это так называемые `breakpoints` - то есть точки, в которых наш макет "ломается" и отображается уже иначе.

Еще вопрос: а откуда брать эти цифры? А это уже зависит от множества факторов: от задач, от макета, от проекта, и т.д.

**Медиа-запросы**
Итак, еще раз: медиа-запросы нам нужны для того, чтобы сказать, что при выполнении каких-то условий на устройстве клиента, наш макет должен отображаться каким-то образом. Давайте рассмотрим пример (опять из наших цветных кубиков). Предположим, что нам нужно, чтобы на больших экранах (свыше 900 пикселей), мы рендерили их в виде сетки из 4 столбцов, а на всех меньших экранах - в виде сетки из двух столбцов.

Как нам это сделать? Первое - это задать стиль "по умолчанию", то есть без всяких медиа-запросов. Пусть у нас стилями по умолчанию будут стили для больших экранов (об этом тоже поговорим чуть позже). Тогда нам нужно записать стили для больших экранов в виде обычного СSS, а все что меньше - запишем в медиа-запрос.

Вот как это будет выглядеть:
```
.gridContainer {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
}

@media screen and (max-width: 900px) {

  .gridContainer {
    grid-template-columns: repeat(2, 1fr);
  }
}
```

То есть, добавляется медиа-запрос с условием "только для экранов", и только для тех, у которых максимальная ширина - 900 пикселей. Почему только для экранов - потому что еще бывают другие устройства (например, принтеры). Тип устройства писать необязательно, но хуже от него точно не будет.

На что еще здесь следует обратить внимание? На то, что мы **не переписываем абсолютно все стили в медиа-запросе**. Мы только указываем то, что мы хотим переопределить. То есть, "перекрыть" стилями медиа-запроса стандартные стили. И CSS применит к нашему контейнеру обычные стили, а затем, если мы на устройстве с экраном меньше 900 пикселей - то применит еще и стили из медиа-запроса.

В медиа-запросах чаще всего мы будем оперировать минимальной/максимальной шириной экрана. Это **min-width**, **max-width** соответственно. Еще можно оперировать высотой, ориентацией экрана, и рядом других факторов, но это мы пока затрагивать не будем.

**Закрепим практикой**
1. Для контейнера `experimentalGrid`, сделайте так, чтобы на экранах шириной до 520 пикселей, он бы отображался как сетка из 2 столбцов. Все, что больше - сетка из 4 столбцов.
2. Теперь сделайте так, чтобы на экранах шире 900 пикселей наша сетка отображалась бы в виде сетки из 6 столбцов.

**Порядок определения медиа-запросов**
Мы можем определить столько медиа-запросов, сколько сочтем нужным, то есть мы никак не ограничены. Но возникает вопрос, в какой последовательности определять эти запросы, особенно с учетом того, что CSS читается сверху вниз? На этот вопрос есть два варианта ответа, или два подхода в написании медиа-запросов.
- *mobile-first* - в этом случае, мы пишем ВНЕ медиа-запросов стили для самых маленьких экранов (мобильных устройств), а затем определяем стили "по возрастанию", и оперируем *min-width*. То есть, мы последовательно "расширяем" экраны. Сначала, в стилях по умоланию, определяем стили для смартфонов. Затем пишем медиа-запрос со стилями для планшетов. Затем - для ноутбуков, затем для декстопов.
- *desktop-first* - а в этом случае, мы пишем ВНЕ медиа-запросов стили для самых больших экранов (десктопов), а затем определяем стили "по убыванию", и оперируем *max-width*. Здесь мы последовательно "сужаем" экраны.

Рассмотрим на примерах. Предположим, что мы хотим, чтобы наша сетка `gridContainer` на смартфонах (до 520 пикселей) - в 2 столбца. На планшетах (до 700 пикселей) - 4 столбца, и на всем что шире - в 6 столбцов. Попробуем это записать в виде *mobile-first*, а потом перепишем на *desktop-first*.

```
/*mobile-first*/
.gridContainer {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
}

@media screen and (min-width: 520px) {

  .gridContainer {
    grid-template-columns: repeat(4, 1fr);
  }
}

@media screen and (min-width: 700px) {

  .gridContainer {
    grid-template-columns: repeat(6, 1fr);
  }
}
```

То есть у нас получается стиль по умолчанию - для смартфонов. Давайте предположим, что мы зашли на такой сайт с устройства с шириной экрана 600 пикселей. Стили будут читаться сверху вниз. Первый медиа-запрос выполняется, поэтому мы увидим сетку из 4 столбцов. Второй медиа-запрос не выполняется (600 меньше 700) - то есть сетку в 6 столбцов мы НЕ увидим.

Перепишем на desktop-first.
```
/*desktop-first*/
.gridContainer {
  display: grid;
  grid-template-columns: repeat(6, 1fr);
}

@media screen and (max-width: 700px) {

  .gridContainer {
    grid-template-columns: repeat(4, 1fr);
  }
}

@media screen and (max-width: 520px) {

  .gridContainer {
    grid-template-columns: repeat(2, 1fr);
  }
}
```

И теперь мы имеем совсем другую картиину. Опять же, предположим, что зашли с устройства 600 пикселей шириной. CSS читаются сверху вниз. На первом шаге, применятся стили "по умолчанию". Затем, применятся стили из медиа-запроса на 700 пикселей (т.к. 700 больше 600). Они перекроют `grid-template-columns` из стилей по умолчанию. А вот стили из медиа-запроса на 520 пикселей применены не будут, потому что 520 меньше 600, и условие не выполняется.

Какой применять подход при верстке своих проектов - зависит только от Вас. Никаких плюсов или минусов - это просто два пути к цели, одинаковой длины.

**Закрепим практикой**
1. Используя подход `mobile-first`, сделайте так, чтобы контейнер `.experimentalGrid` отображался бы как сетка таким образом:
 - на смартфонах (до 375 пикселей) - в 1 столбец
 - на больших смартфонах (376-520 пикселей) - 2 столбца
 - на планшетаз (521-700 пикселей) - в 4 столбца
 - на всем остальном - в 8 столбцов.
2. Теперь решите аналогичную задачу с помощью `desktop-first` подхода.

До сих пор, мы рассматривали только управление шаблоном столбцов сетки с помощью медиа-запроса. Разумеется, это не все, чем можно управлять. По факту, мы можем в медиа-запросах переопределять все, что угодно - любые стили. Мы можем сделать размер шрифта чуть больше на маленьких экранах, можем что-то скрывать/показывать в зависимости от размера экрана - да все что угодно! Давайте попробуем еще немного закрепить практикой.

1. Сделайте так, чтобы на экранах до 520 пикселей шириной, не отображался бы `.box5`.
2. Сделайте так, чтобы на экранах свыше 700 пикселей шириной, кубик `.box7` красился бы в красный цвет.
3. На малых экранах (до 375 пикселей), увеличивайте размер шрифта для всего внутри контейнера `.experimentalGrid` до 20 пикселей.
4. Задача со звездочкой. Сделайте так, чтобы на экранах от 375 пикселей до 520 пикселей шириной, наша сетка отображалась бы в виде сетки в 4 столбца, а во всех остальных случаях - в один столбец.

И теперь решим реальную практическую задачу. Нам предстоит сверстать адаптивный макет формы регистрации - по ссылке https://www.figma.com/file/5v2xzbBTYHwsSVPpX1UUiz/SignUpForm_Adaptive?type=design&node-id=3-2&mode=design&t=5Z37MI74oU1y3ZSZ-0. Задачу предлагается решать следующим образом: разбиением на мелкие подзадачи, обсуждением путей решения, и самостоятельным выполнением.


### Полезные ссылки
 - (Русскоязычный гайд)[https://itchief.ru/html-and-css/media-queries] по адаптивной верстке.