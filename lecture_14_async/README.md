 # README

## Лекционное занятие №14

### Тема:

Репозитарий содержит материалы по лекционному занятию №14, посвященному работе с асинхронными задачами в JS.

**Вводная, мотивационная часть**
Cегодня поговорим об отложенном выполнении задач. Что имеется в виду? Ранее, мы с вами работали с кодом, который будет выполняться немедленно, в момент его запуска. То есть, мы пишем блок кода, и он будет выполнен тут же, при загрузке скрипта. Но JS также предоставляет нам возможности отложенного выполнения. Это нужно тогда, когда мы хотим что-то выполнить не прямо сейчас, а спустя некоторое время. То есть, запланировать выполнение чего-то на будущее. JS предоставляет нам инструменты для этого, но перед тем как их рассмотреть, разберем еще понятия синхронного и асинхронного кода.

 - Синхронный код - это то, с чем мы привыкли работать, то есть команды выполняются последовательно, одна за другой, и выполняются немедленно.
 - Асинхронный код - это задачи, которые выполняются не прямо сейчас, а потом. То есть, или выполнение задачи требует некого количества времени, и это количество мы не знаем - оно от нас не зависит, или же эту задачу нужно выполнить спустя какое-то время.

**Инструмент для планирования задач**
В JS есть очень удобный инструмент для планирования выполнения чего-то спустя какое-то время. Этот инструмент - `setTimeout`. Это функция, которая планирует выполнение другой функции спустя какое-то время. `setTimeout` - это метод window, то есть доступен нам из коробки.

```
function myFunc() {
   console.log('Hello!');
}

setTimeout( myFunc, 1000 ); // функция myFunc будет вызвана через 1 секунду (1000 миллисекунд)
```

`setTimeout` ожидает от нас:
 - первым аргументом функцию-колбэк, то есть ту логику, которую мы хотим выполнить с задержкой.
 - вторым аргументом - время задержки В МИЛЛИСЕКУНДАХ!!!
 - третьим и последующими аргументами - аргументы, которые нужно передать в колбэк при вызове (об этом чуть позже).
 - setTimeout вернет нам *идентификатор запланированного таймера* - о нем тоже поговорим чуть позже

То есть, вызывая `setTimeout`, мы как бы говорим: "эй, JS, держи блок кода, но выполнишь его не прямо сейчас, а через определенное время". И JS нам скажет "да, конечно, а пока что я продолжу выполнять остальные задачи".

Что имеется в виду? То, что JS - трудолюбивый товарищ, и чтобы не тратить время зря, он будет выполнять дальнейшие задачи. То есть тот факт, что мы запланировали выполнение некого блока через какое-то время, не будет тормозить скрипт на это время.

```
console.log('Start');

setTimeout( () => { console.log('Scheduled') }, 1000 );

console.log('End');
```

Скрипт выведет в консоль такую последовательность: Start - End - Scheduled. То есть, когда мы планируем отложенное выполнение, мы НЕ тормозим выполнение всего скрипта - мы просто просим выполнить именно это действие спустя какое-то время, а пока что продолжаем выполнение других (синхронных) команд. Все, что стоит внутри таймаута, можно считать асинхронным кодом (то есть код выполнится не вотпрямщас, а спустя какое-то время).

**Закрепим практикой**
1. Написать блок кода, который выведет в консоль фразу "5 seconds passed" спустя 5 секунд после загрузки скрипта.
2. Написать блок кода, который запросит у пользователя время задержки в СЕКУНДАХ (через `prompt`). Нужно спустя это количество секунд, вывести в консоль сообщение "Hey there!".

**Отмена запланированного действия**
Когда мы планируем какое-то действие, то вовсе необязательно, что по истечении времени задержки мы все еще будем хотеть выполнить это действие. Мы можем передумать, у нас может измениться что-то в нашей программе, и все такое. Например, мы хотим при открытии страницы товаров, спустя 30 секунд, показать всплывающее окно "Хотите перезвоним Вам через минуту?". И мы при загрузке скрипта планируем это действие. Но если пользователь ушел со страницы товаров, то нам уже не нужно показывать это окно. То есть, нам надо отменить планируемое действие. В этом нам поможет `clearTimeout` - то есть отмена запланированного.

Но, чтобы что-то отменить, нужно знать конкретно, что же мы хотим отменить - ведь у нас может быть много запланированных действий (т.е. много таймаутов) на нашей странице. Тут-то нам и пригодится то, что возвращает `setTimeout` - идентификатор таймера. И мы сможем сказать "эй, JS - мы передумали, и уже не хотим, чтобы ты выполнял это действие".

```
const timerId = setTimeout( () => { console.log('This will not appear in the console!'); }, 1000 );

const anotherTimerId = setTimeout( () => { console.log('This will be shown!') }, 1000 );
// отменяем таймер
clearTimeout(timerId);
```

То есть мы видим, что первый таймер (который мы отменили), не выполнился. А вот второй успешно выполнился спустя 1 секунду.

*Важный момент*: нужно **НЕ ЗАБЫВАТЬ** чистить таймеры, то есть убирать за собой. Ненужный таймер может создать утечку памяти, кинуть исключение, и многое другое, поэтому лучше "уходя, гасить всех" - то есть убирать таймеры, если они уже не понадобятся.

**Закрепим практикой**
1. Написать блок кода, который будет планировать вывод в консоль текста "Delayed message" через 5 секунд после запуска скрипта. Запросить у пользователя ввод слова (через prompt). Если пользователь ввел `cancel` - отменить вывод в консоль.
2. Делаем блок на странице, который будет запускать отложенное выполнение, и заодно вспоминаем работу с DOM. Нужно написать функцию `renderDelayedBlock`. Она должна будет сделать инпут, в который будем вводить задержку в секундах, и кнопку "Запуск". При нажатии на кнопку "Запуск", нужно через N секунд вывести сообщение "Delayed message". N - это кол-во секунд, введенное в инпуте.
3. Дорабатываем наш блок. Добавляем кнопку "Отмена". Изначально она должна быть скрыта (рекомендуется воспользоваться CSS).
 - когда мы нажимаем на кнопку "Запуск", мы показываем кнопку "Отмена".
 - при нажатии на кнопку "Отмена", нам нужно отменить запланированное в `setTimeout` выполнение.
 - если выполнение все же произошло (т.е. функциональность внутри `setTimeout` выполнилась), то кнопку "Отмена" скрываем.

**Передача аргументов в `setTimeout`**
И теперь пара слов о том, как можно передавать аргументы в функцию, которую мы вызываем с задержкой. Зачастую, то действие, которое выполняется с задержкой, определяется прямо в таймауте. Но иногда, это действие (функция) определено заранее, и ожидает аргументы. И вот чтобы передать эти аргументы, мы можем воспользоваться аргументами `setTimeout`.

```
function greetUser(username) {
   console.log(`Hello, ${username}!`);
}

setTimeout( greetUser, 1000, 'Vasya' );
// спустя 1 секунду, в консоли будет текст `Hello, Vasya!`.
```

На практике встречается довольно редко, но тем не менее, это тоже интересная возможность таймаута.

**Регулярное выполнение**
Доселе, мы разобрали только ситуацию, когда мы хотим выполнить блок кода только один раз, спустя какое-то время. Но иногда бывают ситуации, когда нам нужно выполнять наш код регулярно. Например, каждые 60 секунд посылать специальный запрос на сервер, чтобы уведомить его о том, что нашу сессию еще рано закрывать, мы все еще здесь, просто думаем. Или просто показывать актуальное время (которое будет меняться каждую секунду). Для этого, у нас есть функция `setInterval`.

```
const intervalId = setInterval( () => {
   console.log('Tick!');
}, 5000);
```

Каждые 5 секунд в консоль будет выводиться сообщение `Tick!`.

*ВАЖНО!* Этот метод НЕ ГАРАНТИРУЕТ стопроцентно точного времени, то есть именно 5000 миллисекунд между выполнениями! Если важно именно точное время задержки - лучше используйте вложенный `setTimeout` (см. полезные ссылки).

Как мы видим, интервал тоже возвращает нам идентификатор интервала, который впоследствии может быть очищен методом `clearInterval`.

И точно так же, как и у таймаута, все что внутри интервала - рассматривается как асинхронный код. Даже если там указана нулевая задержка.

```
console.log('Start');
const intervalId = setInterval( () => {
   console.log('Tick!');
}, 0);
console.log('Finish');

// Start - Finish - Tick - Tick - ...
```

**Закрепим практикой**
1. Написать блок кода, который каждые 2 секунды будет выводить в консоль текст "2 seconds passed!".
2. Доработать блок кода из первой задачи - после пятого сообщения прекратить выполнение этого блока.
3. Добавляем на страницу текущие дату и время. Нужно добавить в разметку блок, в котором должны отображаться текущие дата и время, вида `01.01.2000 11:23:55`. И нужно сделать так, чтобы дата и время отображались актуальные (т.е. обновлять текст ежесекундно).
4. Реализуем простой секундомер. Нужно добавить в блок с id=`simpleTimerContainer` секундомер. В блоке будут:
 - параграф, в котором будем выводить текущее время секундомера
 - кнопка "Старт" - при нажатии запускаем секундомер
 - кнопка "Сброс" - при нажатии сбрасываем секундомер.
5. Усложняем наш секундомер. Нам нужно добавить кнопки "Пауза", "Возобновить". Первая будет приостанавливать, но не сбрасывать секундомер, а вторая - возобновлять его работу.



### Полезные ссылки
 - Глава учебника про (отложенное выполнение)[https://learn.javascript.ru/settimeout-setinterval]