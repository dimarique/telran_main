# README

## Лекционное занятие №43

### Тема:

Репозитарий содержит материалы по лекционному занятию №43, посвященному основам оптимизации в `React` - использованию хуков `useCallback`, `useMemo`.

### Цели занятия
- повторение и закрепление знаний;
- решение задач.

### useCallback
**Определение из документации:** `useCallback` - хук, который позволяет закешировать определение функции между ререндерами.
На удивление, в этот раз определение из документации довольно "человекопонятное".

**Синтаксис**
```
export default function MyReactComponent(props) {
  const cachedFunction = useCallback( () => {
    // My awesome function
  }, []);

  //...

  return (
    // Super JSX layout
  );
}
```

**Когда использовать колбэки**
Их нужно использовать ТОЛЬКО для оптимизации производительности, в строго определенных случаях:
 - кэширование определения функции, которая передается в пропсах в дочерний "чистый" компонент
 - избежание слишком частого вызова эффекта, если в массиве зависимостей эффекта - функция, определенная в компоненте.
 - оптимизация кастомных хуков.

**React.memo** - это классное средство, которое позволяет ОБОЗНАЧИТЬ компонент как "чистый". Что есть "чистый" компонент: это компонент, который при одинаковых пропсах возвращает одинаковый результат рендеринга (т.е. зависит только от своих пропсов).

**Синтаксис**
```
function MyPureComponent(props) {
  return (
    // Super JSX layout
  );
}

export default memo(MyPureComponent); // компонент обозначен как "чистый".
```

### Задачи useCallback, React.memo
1. У нас есть компонент `CallbackPage`. На нем есть инпут, в котором мы вводим данные, есть кнопка, и есть список "попыток". Каждый раз при вводе чего-то в инпут, компонент списка попыток перерисовывается. Исправьте это.
2. Добавьте возможность удаления попыток. Нужно сделать так, чтобы при клике на попытку в списке попыток, эта попытка удалялась.
3. Проверьте, не "сломалась" ли оптимизация (т.е. не перерисовывается ли компонент `AttemptsList` каждый раз при изменении инпута). Если сломалась - порассуждайте, почему так, и поправьте.

### useMemo
**Определение из документации:** `useMemo` - хук, который позволяет закешировать результат вычислений между ререндерами. То есть, чем-то напоминает `useCallback` - но только `useCallback` кеширует саму функцию (ее определение), а `useMemo` - результат функции.

**Синтаксис**
```
export default function MyReactComponent(props) {
  const memoizedResult = useMemo( () => {
    // My awesome function
    return result;
  }, []);

  //...

  return (
    // Super JSX layout
  );
}
```
Видим, что у хука также есть массив зависимостей. В этот массив следует передать те пропсы/фрагменты стейта, при изменении которых следует пересчитать кэшированное значение.

Важно! Функция, которая указывается в качестве первого аргумента `useMemo`, должна быть:
 - чистой (т.е. независимой от чего-то "снаружи" фукнкции, что не указано в массиве зависимостей)
 - не принимать аргументов

Хук `useMemo` при первом рендере компонента вызовет мемоизированную функцию, и вернет ее результат. При последующих рендерах, он будет возвращать:
 - кешированное значение, если ничего из массива зависимостей не изменилось
 - вычислит новое значение, если что-то из массива зависимостей изменилось.

Когда использовать `useMemo`:
 - для кэширования сложных вычислений (если есть функция, которая затратная по производительности)
 - для кэширования результатов вычислений, которые передаются в пропсах в дочерние компоненты (для оптимизации производительности и избежания лишних ререндеров дочерних компонентов)

### Задачи useMemo
1. У нас есть компонент `CallbackPage`. В нем есть функция `heavyCalculation`, которая путем вычислений невероятной сложности возвращает 2-е число Фибоначчи. Она вызывается при каждом рендеринге компонента. Давайте это исправим, и мемоизируем ее.
2. Теперь предположим, что наша функция зависит от значения, введенного в инпут. Реализуйте это.
3. Давайте немного поменяем реализацию. Предположим, что наш компонент `AttemptList` теперь рендерит не все попытки, а только те, которые содержат букву `A` в значении. То есть нам нужно отфильтровать массив попыток, и передать отфильтрованный массив в `AttemptsList`. Подумайте, кто тут будет хорошим кандидатом на мемоизацию, и что передать в массиве зависимостей.

## Полезные ссылки по занятию:
 - [useCallback](https://react.dev/reference/react/useCallback#) - официальная документация
 - [Оптимизация через useCallback](https://habr.com/ru/articles/590577/) - русскоязычная, очень толковая информация - рекомендуется к прочтению!
 - [useMemo](https://react.dev/reference/react/useMemo) - официальная документация