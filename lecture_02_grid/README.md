# README

## Лекционное занятие №2

### Тема:

Репозитарий содержит материалы по лекционному занятию №2, посвященному работе с CSS Grid.

### CSS Grid
Как только в спецификации CSS появились флексы, жить разработчикам (а особенно верстальщикам), стало гораздо проще - флексы решали массу проблем, и позволяли делать действительно гибкие интерфейсы. Но разработчики CSS на этом не остановилиь, и подарили нам **Grid Layout**. Сегодня попробуем разобраться и с этим, и ответить на вопросы, зачем оно надо, и как это работает.

В базовом варианте, Grid Layout позволяет нам строить нашу разметку в виде сетки (или таблицы) - неожиданно, правда? В основе такой разметки лежит сетка, которая так же как и флексбокс имеет 2 оси: основную и вспомогательную. Эту сетку нам обеспечивает родительский элемент с правилом `display: grid`, то есть контейнер (**grid container**). В ячейках этой сетки (т.е. на пересечении строк и столбцов), размещаются ПРЯМЫЕ потомки (**grid items**). Все довольно сильно напоминает обычный эксель: те же строки, столбцы, ячейки и значения. И точно так же, мы можем объединять ячейки, задавать им ширину, и так далее - но об этом чуть позже.

Возникает закономерный вопрос: а зачем же нам теперь флексбокс, если есть такая классная вещь, как гриды? Ответом на этот вопрос будет следующее: это разные инструменты для выполнения сходных задач. И в некоторых случаях нам нужен будет флексбокс, а в некоторых - лучше использовать гриды. В большинстве случаев это взаимозаменяемые компоновки - то есть большинство того, что делается флексами, реально сделать с помощью гридов, и наоборот. Но есть случаи, когда лучше будет использовать ту или иную компоновку. Например, в ситуации, когда нам нужна сетка с объединением ячеек - однозначно лучше гриды.

### Свойства контейнера
Теперь пришла пора поговорить о том, как мы можем управлять распределением пространства контейнера между ячейками сетки. То есть, сколько ширины должен занимать каждый столбец, и/или сколько высоты должна занимать одна строка. За это отвечают свойства grid contaner-а, то есть свойства, которые мы применим к контейнеру (тому, у кого есть `display: grid`). В контейнере мы определяем структуру сетки, задаем выравнивание элементов, и так далее.

**Управление шаблонами столбцов. grid-template-columns**
Рассмотрим управление ширинами стобцов. За это в грид-контейнере отвечает свойство `grid-template-columns`, то есть шаблоны столбцов сетки. И оно может принимать разные значения:
 - абсолютные (например, пиксели)
 - относительные (проценты, vh, vw, ...)
 - auto (занять столько места, сколько получится)
 - fr (fraction, или доля) - это особо интересный вариант, о котором поговорим отдельно.

Рассмотрим пример. В нашей разметке есть контейнер, с классом `gridContainer`. В нем находятся 4 цветных блока-потомка. Эти потомки - блочные элементы (div-ы), поэтому они заполняют собой всю доступную ширину. Сейчас они заполняют весь блок. Сделаем наш контейнер гридом (добавив ему свойство `display: grid`), и поэкспериментируем со свойством `grid-template-columns` у контейнера.
 - абсолютные единицы
 - относительные единицы
 - auto
 - fractions

**Единица измерения fraction**
Отдельно затронем единицу измерения `fraction`. Это т.н. "доля". Что есть доля, и от чего? Имеется в виду "доля" от свободного пространства, которое осталось после размещения столбцов с другими единицами измерения. Если у нас фигурирует только fraction в шаблонах - то доля от 100% ширины.

Например, у нас стоит задача - сделать сетку из 4 столбцов равной ширины. Для этого, мы можем записать так:
```
.gridContainer {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr 1fr;
}
```

То есть, у нас будет 4 столбца, каждый шириной в 1 долю. Как это будет работать: грид посмотрит, что у него есть только фракции в размерах столбцов. Посчитает их сумму. Поделит 100% на сумму долей. И для каждого столбца возьмет соответствующее количество долей.

В случае, если у нас будет комбинированный шаблон, например, `grid-template-columns: 200px 1fr 1fr 200px;`, то грид возьмет 100%, отнимет от них 400 пикселей, и результат уже будет делить на доли.

И еще интересный момент. Если мы хотим указать повторяющиеся размеры столбцов, мы можем воспользоваться функцией `repeat`.
```
.gridContainer {
  display: grid;
  grid-template-columns: repeat(4, 1fr); // то есть "повтори 1fr 4 раза"
}
```

**Закрепим практикой (grid-template-columns)**
1. В разметке есть блок `div.experimentalGrid`. Сделайте так, чтобы он отображал свои потомки в виде сетки из 3 столбцов. Столбцы должны занимать равную ширину.
2. Для этого же блока, сделайте так, чтобы второй столбец имел ширину 200 пикселей, а остальные столбцы делили оставшееся пространство поровну.
3. Сделайте так, чтобы столбцы имели соотношение по ширине 4:2:1 (то есть первый столбец был бы в 4 раза больше третьего, а второй - в два раза больше третьего).

**Отступы между ячейками. grid-gap**
Еще один интересный момент, на который стоит обратить внимание. Иногда нам нужно добавить "воздуха" между ячейками сетки. За это отвечает свойство `grid-gap` у контейнера. Оно может принимать одно значение (это будет отступ по горизонтали и по вертикали), или два значения (первое - отступ по горизонтали, второе - по вертикали). Фактически, это свойство является сокращенной записью для свойств `column-gap`, `row-gap`.

**Управление шаблонами строк. grid-template-rows**
Теперь поговорим о свойстве `grid-template-rows`. Несложно догадаться, что оно аналогично столбцам, но управляет высотой и количеством строк в таблице. Если мы не задаем это свойство - то количество строк определяется автоматически (в зависимости от контента), а их высота определяется по самой высокой ячейке. Мы можем это увидеть, если зададим одной из наших цветных коробок высоту, например, 350 пикселей, а остальным поставим по 100 пикселей.

Важный момент! Если мы хотим использовать какие-то относительные единицы, типа `auto`, процентов, долей и т.д., то мы должны обеспечить фиксированную высоту грид-контейнера, чтобы он понимал, от чего ему отталкиваться. В противном случае он будет базироваться на высоте контента.

**Закрепим практикой (grid-template-rows)**
1. Удалим все ограничения по высоте для наших цветных кубиков. Сделаем так, чтобы `div.experimentalGrid` отображался бы в виде сетки 3х3, при этом высота первой строки - 200 пикселей, второй - 250, а третьей - 300 пикселей.
2. Для этого же блока, сделайте так, первая строка занимала 200 пикселей высоты, а вторая и третья - столько, сколько нужно их содержимому.
3. Сделайте так, чтобы строки имели соотношение по высоте 3:2:1. Здесь рекомендуется добавить еще кое-что в стили контейнера, чтобы он понимал, доли от чего ему брать.

**Управление шаблонами строк и столбцов. grid-template-areas**
Есть еще один интересный (и иногда востребованный) способ задания шаблона сетки. Это `grid-template-areas`. Он позволяет указать "области" сетки, в которых разместится содержимое. При его использовании, следует помнить, что ячейки сетки могут занимать только прямоугольные области.
```
.gridContainer {
  display: grid;
  grid-template-areas:
      "A A A"
      "B B C"
      "B B C";
}

.box1 {
  grid-area: A;
}

.box2 {
  grid-area: B;
}

.box3 {
  grid-area: C;
}
```

На примере, мы можем заметить, что мы задали шаблон сетки, где есть область А (занимает первую строку целиком), есть область В (занимает первые 2 столбца второй строки и первые 2 столбца третьей), и область С (занимает последний столбец второй и третьей строк). И мы также видим, что мы указываем некоторым грид-элементам, какие конкретно области они должны занимать. То есть первый блок занимает область А, второй - область В, третий - область С. Остальные блоки уже "подстраиваются" под существующую разметку.

Особо интересным является распределение остальных элементов. Они распределяются оптимальным образом, чтобы занять как можно меньше места.

**Закрепим практикой (grid-template-areas)**
1. С помощью `grid-template-areas`, сделайте так, чтобы у нас была сетка из 3 столбцов, при этом первый элемент занимал полностью первую строку, второй - полностью вторую.
2. С помощью `grid-template-areas`, сделайте сетку из 3 столбцов, чтобы 1-й элемент занимал полностью первую строку, второй занимал бы первый столбец во второй и третьей строках, третий занимал бы второй столбец во второй и третьей строках.

**Выравнивание содержимого ячеек. justify-items, align-items**
Иногда, содержимое ячеек занимает меньше места, чем сами ячейки. То есть, у нас остается свободное пространство в ячейках. И мы можем управлять выравниванием содержимого ячеек по горизонтали (основная ось) и вертикали (вспомогательная ось), с помощью свойств `justify-items`, `align-items`. Работают они очень похоже на `justify-content`, `align-items` у флексов.

Поэкспериментируем с выравниванием содержимого ячеек. Для этого, зададим нашим кубикам ограничения по высоте и ширине, и зададим такой шаблон сетки, чтобы в ячейках было свободное пространство.

**Закрепим практикой (justify-items, align-items)**
1. В контейнере `div.experimentalGrid`, добавьте всем кубикам ограничения по ширине и высоте (100 пикселей на 100 пикселей). Реализуйте шаблон сетки из 2 строк и 4 столбцов, строки высотой по 200 пикселей, столбцы все равной ширины. Сделайте так, чтобы содержимое ячеек было выровнено по центру по обеим осям.
2. Теперь сделайте так, чтобы содержимое прижималось к правому нижнему углу ячеек.

**Строки и столбцы по умолчанию. grid-auto-rows, grid-auto-columns**
Ранее, когда мы задавали шаблоны строк, мог возникнуть вопрос: а что, если того количества строк, которые мы определили в шаблоне, не хватит для размещения контента? Или если предположить, что наша таблица растет не вниз, а вправо (то есть мы добавляем не строки, а столбцы для нового содержимого) - как таблица поймет шаблон нового столбца? Для этого, существуют свойства `grid-auto-rows`, `grid-auto-columns`.

`grid-auto-rows` - оно как бы говорит: "грид, если тебе понадобится добавлять новые строки, которые НЕ определены в `grid-template-rows`, то для них используй вот такой шаблон высоты.

`grid-auto-columns` делает то же самое для столбцов.

Рассмотрим пример:
```
.gridContainer {
  grid-template-columns: repeat(2, 1fr);
  grid-template-rows: 200px; /* говорим что у нас должна быть одна строка в таблице, высотой 200 пикселей */
  grid-auto-rows: 100px; /* говорим что если содержимое не влезло в одну строку - то новые строки будут высотой 100 пикселей */
}
```

Для того чтобы сказать таблице, куда ей расти (в высоту или в ширину), есть свойство `grid-auto-flow`.

### Свойства потомков
Затронем тему CSS-правил, которые применяются для управления отображением конкретных потомков. Как в случае с флексбоксом, каждый потомок может иметь какие-то свои настройки, которые будут "перекрывать" настройки уровня контейнера. И начнем мы с выравнивания.

**Выравнивание конкретных потомков. justify-self, align-self**
Каждый элемент сетки может сказать, как конкретно он хочет выравниваться. Для выравнивания по горизонтали используем `justify-self`, для вертикали - `align-self`.

Пример:
```
.gridContainer {
  grid-template-columns: repeat(3, 1fr);
  grid-template-rows: repeat (2, 200px);
  justify-items: center;
  align-items: center;
}

.gridItem {
  width: 100px;
  height: 100px;
}

.box2 {
  justify-self: left;
  align-self: bottom;
}
```

На примере видим, что у нас есть таблица, в которой элементы выровнены по центру ячеек. А box2 имеет свое выравнивание, левый нижний угол ячейки.

**Закрепим практикой (justify-self, align-self)**
1. В контейнере `div.experimentalGrid`, добавьте всем кубикам ограничения по ширине и высоте (100 пикселей на 100 пикселей). Реализуйте шаблон сетки из 3 строк и 3 столбцов, строки высотой по 200 пикселей, столбцы все равной ширины. Сделайте так, чтобы содержимое ячеек было выровнено по центру по обеим осям. Кубик с классом `box3` должен быть прижат к правому верхнему углу своей ячейки.
2. Кубик с классом `box5` должен быть выровнен по центру по горизонтали, и прижат к нижнему краю по вертикали.
3. Кубик с классом `bo4` должен быть выровнен по центру по вертикали, и прижат к правому краю по горизонтали.

**Указание области, которую должен занимать элемент грида. grid-row, grid-column**
Мы уже рассматривали, как мы можем попросить элемент сетки занять несколько ячеек. Для этого мы используем `grid-template-areas`. Но это не всегда удобно (зачастую неудобно), поэтому гриды любезно предоставляют нам возможность указать элементу сетки, какие конкретно ячейки он должен занимать. Для этого используются:
 - grid-column: a / b  -  для указания столбцов, которые занимает элемент
 - grid-row: c / d  -  для указания строк, которые занимает элемент

Оба эти свойства являются сокращенной записью. Можно записать также следующим образом:
```
.box1 {
  grid-column: 1 / 3;
  /* это эквивалентно такой записи /*
  grid-column-start: 1;
  grid-column-end: 3;
}
```

*ВНИМАНИЕ, ВАЖНЫЙ МОМЕНТ!* Когда мы говорим start = 1, end = 3, то это не значит "займи столбцы с 1-го по 3й". Грид в данном случае оперирует не столбцами, а ЛИНИЯМИ СЕТКИ! То есть мы как бы говорим "начнись на 1-й вертикальной линии сетки, и завершись на 3-й вертикальной линии сетки". То есть в данном случае, наш элемент будет занимать 2 и 3 столбцы.

Для строк работает так же.

**Закрепим практикой (grid-column, grid-row)**
1. В контейнере `div.experimentalGrid`, укажите шаблон сетки - 3 столбца равной ширины. Сделайте так, чтобы кубик с классом box2 занимал 2 и 3 столбцы первой строки.
2. Кубик с классом box3 должен занимать всю вторую строку.
3. Кубик с классом box4 должен занимать первый столбец третьей и четвертой строк.
4. Кубик с классом box5 должен занимать второй и третий столбцы третьей и четвертой строк (то есть место, оставшееся от box4).


### Домашнее задание
Сверстать сайт из прошлого [задания](https://www.figma.com/design/ntTbBfeG8m53kLoriar4QX/Untitled?node-id=1-228), при этом используя гриды. Флексы использовать НЕ запрещается.

### Полезные ссылки
 - Подробный гайд по [Grid](https://css-tricks.com/snippets/css/complete-guide-grid/) - англ.
 - Примерно аналогичная статья на русском [на Хабре](https://habr.com/ru/companies/macloud/articles/564182/).
 - Русскоязычный гайд по [Grid](https://medium.com/@stasonmars/%D0%B2%D0%B5%CC%88%D1%80%D1%81%D1%82%D0%BA%D0%B0-%D0%BD%D0%B0-grid-%D0%B2-css-%D0%BF%D0%BE%D0%BB%D0%BD%D0%BE%D0%B5-%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE-%D0%B8-%D1%81%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA-220508316f8b)
 - Еще одна очень полезная [статья](https://medium.com/@stasonmars/%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D1%8E%D1%82-auto-fill-%D0%B8-auto-fit-%D0%B2-css-grid-7d903a6c678e) от Макса Багрецова, как работают minmax, auto-fill, auto-fit в гридах. Это уже advanced-тема, но настоятельно рекомендуется.
