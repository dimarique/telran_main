# README

## Лекционное занятие №34

### Тема:

Репозитарий содержит материалы по занятию, посвященному хуку `useEffect`, и его использованию при работе с сетью.

### Цели занятия
- повторение и закрепление знаний;
- решение задач.

### Зачем это нужно
Как мы помним, хук `useEffect` нужен для работы с т.н. "сайд-эффектами", и для синхронизации компонента с внешней системой. Самым типичным примером использования хука `useEffect` является запрос к бэку, за какими-либо данными. Это нужно выполнить после рендеринга, и по завершении запроса перерисовать компонент с полученными данными. Сегодня будем говорить об этом.

### Пример использования
Рассмотрим пример. У нас есть компонент, который отвечает за отрисовку данных о конкретном товаре. Этот компонент берет данные с бэка, по определенному адресу, `https://dummyjson.com/products/1'`, где 1 - это идентификатор товара. Перед нами стоит задача: запросить данные о товаре, и показать их на экране.

Пусть наш компонент отображает название, описание и цену товара, и генерирует такую разметку:
```
export default function ProductCard( {productId} ) {

  return (
    <div className='productCardContainer'>
      <h3 className='productName'></h3>
      <p className='productPrice'></p>
      <p className='productDescription'></p>
    </div>
  )
}
```

Возникает вопрос - откуда взять данные: название, цену, и т.д.? Они живут на сервере, и сервер нам их предоставит по запросу. То есть, нам нужно их запросить.

В какой момент нам нужно запрашивать эти данные? Возникает искушение поставить отправку запроса прямо в компонент. Но это нехорошее решение - потому что при таком решении запрос будет отправляться каждый раз при перерисовке компонента. Вывод - нужно привязаться к какой-то фазе жизненного цикла компонента. Пожалуй, нам здесь подойдет только фаза монтирования. То есть, нам понадобится `useEffect`, чтобы выполнить наш запрос при монтировании компонента.

```
import { useEffect } from 'react';

export default function ProductCard( {productId} ) {

  useEffect( () => {
    fetch('https://dummyjson.com/products/' + productId)
      .then( res => res.json())
      .then( product => {
        // .. do something with product data
      })
  }, []);

  return (
    <div className='productCardContainer'>
      <h3 className='productName'></h3>
      <p className='productPrice'></p>
      <p className='productDescription'></p>
    </div>
  )
}
```

Теперь у нас при монтировании компонента отправляется запрос. Но это еще не все. Первый момент - у нас наш эффект зависит от пропса `productId` - он используется внутри эффекта. Давайте добавим его в массив зависимостей.

И следующий момент. После получения результата, нам нужно как-то показать его на экране. То есть, нам нужно перерисовать компонент (как-то инициировать перерисовку). А значит, нам имеет смысл ввести фрагмент локального стейта, в котором мы будем хранить данные о товаре. И при получении ответа, мы просто положим его в локальный стейт, и попросим наш компонент перерисоваться.

```
import { useState, useEffect } from 'react';

export default function ProductCard( {productId} ) {

  // инициализируем наш стейт пустым объектом
  const [product, setProduct] = useState( {} );

  useEffect( () => {
    fetch('https://dummyjson.com/products/' + productId)
      .then( res => res.json())
      .then( productData => {
        setProduct(productData);
      })
  }, [productId]);

  return (
    <div className='productCardContainer'>
      <h3 className='productName'>{product.title}</h3>
      <p className='productPrice'>{product.price}</p>
      <p className='productDescription'>{product.description}</p>
    </div>
  )
}
```

Чего мы добились? Теперь, при изменении значения пропса `productId`, наш компонент будет "синхронизироваться" с данными о конкретном товаре. При получении ответа от бэка, он положит этот ответ в свой локальный стейт, и перерисуется с уже свежими данными. Соответственно, компонент рисует актуальные данные о товаре.

Можно (и нужно!) проводить дополнительные работы: рассматривать нештатные ситуации, обрабатывать ошибки, и многое другое - но принцип один и тот же.

Разумеется, можно переписать наш эффект с использованием `async/await`.
```
  useEffect( () => {
    const fetchData = async () => {
      const resp = await fetch('https://dummyjson.com/products/' + productId);
      const productData = await resp.json();
      setProduct(productData);
    }
    fetchData();
  }, [productId]);
```

Таким образом, мы понимаем, как использовать эффекты для запросов данных с бэка.

### Задачи на закрепление
1. Тренируемся писать эффекты по работе с сетью. В компоненте `App`, запросите список дел. Он находится по адресу `https://dummyjson.com/todos`. Результат вывести в консоль.
2. Сейчас наши компоненты работают со списком дел, который берется из статичного источника. Сделайте так, чтобы после окончания загрузки списка дел из п.1, он бы помещался в локальный стейт.
3. Добавляем иконку загрузки. Нужно перед началом загрузки списка дел вместо компонента `TodoList` показывать параграф с текстом "Пожалуйста, подождите - идет загрузка". По завершении загрузки, параграф нужно спрятать, а вместо него отрисовать `TodoList`. Задача к размышлению.
4. Добавляем обработку нештатной ситуации. Если при запросе, или при разборе результата что-то пошло не так - то нужно показывать параграф с текстом "Что-то пошло не так, попробуйте позже".
5. Предположим, что наши дела имеют какую-то подробную информацию. Добавьте на каждое дело кнопку "Подробнее". При нажатии на кнопку, нужно отправлять запрос по адресу `https://dummyjson.com/todos/TODO_ID`. Результат выводить в консоль. Задача к размышлению.
6. Немного разнообразим нашу предметную область, и попробуем поработать с товарами. Нужно создать компоненты `ProductList`, `ProductCard`, которые будут рендерить список товаров. Товары берем по адресу `https://dummyjson.com/products`
7. Сделаем возможность фильтра товаров. Нужно реализовать возможность фильтрации товаров по категориям. Список категорий берем с адреса `https://dummyjson.com/products/categories`. Этот список надо отрендерить в виде выпадающего списка категорий, над списком товаров. Предполагается, что при выборе товара в списке, мы будем загружать товары этой категории. Задача также к обсуждению.


### Полезные ссылки
[Жизненный цикл компонента](https://javascript.plainenglish.io/react-lifecycle-methods-in-functional-components-db72e038bd2a) - со схемой и подробным описанием.

[Официальная документация](https://react.dev/reference/react/useEffect#connecting-to-an-external-system) - информативно, с интерактивными примерами. Все "незнакомое", типа кастомных хуков и т.д. - пропускать.

[Русскоязычный гайд](https://habr.com/ru/companies/rshb/articles/687364/) - толково, и с пояснением про ЖЦ компонента.
