# README

## Лекционное занятие №8

### Тема:

Репозитарий содержит материалы по лекционному занятию №8, посвященному работе с массивами в JS.

### Методы sort, reduce.

**Сортировка массива, метод sort**

Задача сортировки массива имеет очень много разных алгоритмов решения. В JS, разработчики решили облегчить жизнь пользователям, и сделали встроенный метод `sort`, который отвечает за сортировку массива. Он также принимает колбэк, но этот колбэк отличается от рассмотренных ранее.

```
const arr = [1, 2, 3, 4, 10, -5, 3, 12, 91, -7];
arr.sort( (elem1, elem2) => {
  return elem1 - elem2;
});
console.log(arr); // отсортированный по возрастанию массив
```

Надо также помнить, что метод `sort` - мутирующий, то есть он сортирует массив по месту (меняет порядок элементов).

Разберем подробнее колбэк, который мы передаем в метод. Это функция, которая:
 - принимает 2 аргумента elem1, elem2 (то есть 2 элемента массива)
 - должна возвращать отрицательное значение, если elem1 должен быть перед elem2 в отсортированном массиве, 0 - если порядок не важен, и положительное значение - если elem1 в отсортированном массиве должен быть после elem2.

То есть, колбэк определяет порядок следования двух элементов в новом массиве.

Если мы не передадим никакой колбэк, то по умолчанию, сортировка будет выполнена в алфавитном порядке.

```
const numbers = [1, 9, 10, 5, 3, 7, 2, 73];
console.log(numbers.sort()); // [1, 10, 2, 3, 5, 7, 73, 9]
const strings ['zulu', 'alfa', 'omega', 'bravo'];
console.log(strings.sort()); // ['alfa', 'bravo', 'omega', 'zulu'];
```

Таким образом, если мы не передаем в `sort` колбэк, то по умолчанию, массив сортируется как массив строк - элементы неявно конвертируются в строки, и осуществляется сортировка в алфавитном порядке.

Теперь рассмотрим сортировку массива объектов. Предположим, у нас есть массив пользователей (объекты со свойством `name`), и мы хотим отсортировать их по возрастанию имени.

```
const users = [
  { name: 'Ivan', login: 'vanya' },
  { name: 'Anton', login: 'toha' },
  { name: 'Dmitry', login: 'dim' }
];

users.sort( (a, b) => {
  return a.name < b.name ? -1 : 1;
});
```

То есть, в колбэке, мы рассматриваем свойство объекта, по которому мы хотим отсортировать наш массив. Есть интересный нюанс по сравнению строк: можно применять операторы "больше", "меньше". JS поймет что мы имеем в виду (вернее, он догадается использовать сравнение не символов, а их кодов в ASCII-таблице). Следует также иметь в виду, что буквы в разном регистре имеют разные коды в таблице, и соответственно, будут иметь нестандартный порядок (сначала сортируются большие буквы, потом маленькие). Поэтому при сравнении строк, лучше их приводить к одному регистру.

**Закрепим практикой**
1. Отсортировать массив строк `strings` по возрастанию.
2. Отсортировать массив чисел `numbers` по возрастанию.
3. Отсортировать массив строк `strings` по убыванию без учета регистра.
4. Отсортировать массив чисел `numbers` по убыванию.
5. Отсортировать массив объектов `products` по возрастанию цены.
6. Отсортировать массив строк по убыванию кол-ва символов в строке;
7. Отсортировать массив объектов `products` по категории (в алфавитном порядке), и по возрастанию цены. Т.е упорядочить по категориям, и в разрезе категорий - по возрастанию цены.

**Метод reduce**
Наиболее интересный метод по работе с массивами, который позволяет сделать из массива некое "агрегирующее" значение. Этот метод пройдется по всему массиву, и вызовет колбэк. И по итогу вернет некое "результирующее" значение. В чем-то, метод `reduce` напоминает метод `forEach`, но только с возможностью запомнить результат предыдущей итерации.

Пока не особо понтяно. Попробуем рассмотреть пример. Пусть у нас стоит задача получить сумму элементов массива.

```
const array = [1,2,3,4,5];
let sum = 0;
array.forEach( el => sum += el );
```

Что у нас здесь происходит? Фактически, мы проходимся по массиву, и на каждой итерации добавляем значение текущего элемента массива к счетчику (`sum`).

А теперь попробуем сделать с использованием `reduce`, и разберем подробно.
```
const sum = array.reduce( (accumulator, value) => {
  return accumulator + value;
}, 0);
```

Что у нас тут происходит, и что это за странный колбэк? По порядку.

Колбэк принимает 2 аргумента. Первый - это результат предыдущей итерации. Второй - это текущий элемент массива. Возникает логичный вопрос - на самой первой итерации, откуда возьмется значение аргумента `accumulator`, если предыдущих итераций не было? Ответ - или из второго аргумента `reduce` (если он задан), или в его качестве будет использован первый элемент массива.

Категорически рекомендуется НЕ ЗАБЫВАТЬ указывать начальное значение аккумулятора.

Пройдемся пошагово по выполнению блока кода.
- первая итерация. `accumulator` = 0 (потому что предыдущей итерации не было), `value` = 1 (первый элемент массива `array`). Колбэк вернет 1 (то есть сумму).
- вторая итерация. `accumulator` = 1 (результат первой итерации), `value` = 2 (второй элемент массива `array`). Колбэк вернет 3 (сумму 1 и 2).
- третья итерация. `accumulator` = 3 (результат второй итерации), `value` = 3 (третий элемент массива `array`). Колбэк вернет 6 (сумму 1 и 2).

И так далее. По итогу, мы получим сумму элементов.

То есть, резюмируем, как работает `reduce`. Этот метод:
 - позволяет из массива сделать некое одно "агрегирующее" значение
 - принимает 2 аргумента: колбэк и начальное значение аккумулятора (которое будет передано при первой итерации)
 - колбэк принимает также 2 аргумента: аккумулятор (то есть результат предыдущей итерации), и значениие (элемент массива текущей итераци)
 - колбэк ОБЯЗАТЕЛЬНО должен что-то возвращать (иначе в качестве аккумулятора на след.итерацию зайдет `undefined`)
 - результатом метода будет то, что вернет колбэк на самой последней итерации.

**Закрепим практикой**
1. Получить сумму элементов массива `numbers`
2. Получить среднее арифметическое массива `numbers`.
3. Получить общую длину всех строк массива `strings` с использованием метода `reduce`.
4. Получить из массива `strings` количество строк, в которых есть буква `T` с использованием метода `reduce`.
5. Получить суммарную стоимость всех товаров массива `products`
6. Из массива строк `strings` получить объект, в котором ключами будут строки из массива, а значениями - длины этих строк. Пример:
 ```
 // Исходный массив
 let arr = ["This", "is", "an", "array", "of", "strings"];
 // Ожидаемый результат
 {
  this: 4,
  is: 2,
  an: 2,
  array: 5,
  of: 2,
  strings: 7
 }
 ```
7. Получить массив категорий товаров (т.е. нужно пройтись по массиву товаров методом reduce, и добавлять в "аккумулятор" свойство category рассматриваемого товара)
8. Задача "со звездочкой". Получить объект, в котором будут суммарные стоимости товаров по категориям.


### Полезные ссылки
 - Справочник (методов)[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array] массивов
 - [Интерактивный пример reduce](https://doka.guide/js/array-reduce/) - на более глубокое понимание метода reduce.
 - Доходчиво про (reduce)[https://www.freecodecamp.org/news/how-to-use-javascript-array-reduce-method/] на примерах