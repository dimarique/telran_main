# README

## Итоговое занятие №5

### Тема:

Репозитарий содержит материалы по итоговому занятию №5, посвященному работе с DOM средствами JavaScript.

**Мотивационная часть. Зачем это нужно**
Как мы знаем, HTML - это не язык программирования, это язык разметки. То есть, с помощью HTML, CSS мы можем создавать только статичные сайты (красивые картинки). Подавляющее большинство всего интерактива (то есть взаимодействия с пользователем), и динамики (эффекты, добавление/удаление/изменение чего-то на странице) реализуется только с помощью JavaScript, который является языком программирования. То есть, наш язык нам нужен в первую очередь для добавления динамики на веб-страницу (а не для написания унылых скриптов со скучными массивами).

**DOM-дерево. Работа с элементами**
Начнем с того, что дадим определение DOM. Это аббревиатура, Document Object Model, объектная модель документа. Что за документ, и при чем тут объекты? Будем разбираться.

Все элементы разметки (HTML-теги), имеют свое "отражение" в обычные JS-объекты. То есть, где-то в недрах памяти JS, каждому тегу, каждому текстовому узлу в разметке соответствует какой-то объект в JS. В зависимости от того, какой это конкретно тег, у соответствующего объекта будет определенный набор свойств и методов. И это логично - потому что, например, полям ввода нужно как-то иметь возможность получить свое "содержимое" (то, что ввел пользователь), а тем же div-ам, или параграфам такое не нужно. Точно так же, некоторые элементы имеют возможность реагировать на разные события.

Таким образом, мы делаем вывод, что каждому ЭЛЕМЕНТУ разметки, соответствует JS-объект. Чуть позже, докажем это на практике.

Ранее, мы работали только с элементами, которые указаны в разметке. Но JavaScript дает нам возможность полноценно управлять элементами: создавать новые, изменять существующие, удалять существующие. Прежде чем начать работу с элементами, мы поговорим о поиске по DOM-дереву.

**Поиск по DOM-дереву**
В большинстве случаев, дерево элементов нашего проекта будет ОЧЕНЬ развесистым, с большим количеством вложенных уровней, и т.д. И нам нужно уметь искать по этому DOM-дереву. То есть, иметь возможность находить в нем конкретный элемент (или множество элементов), которые удовлетворяют критерию поиска. И для этого, JS любезно предоставляет нам несколько методов.

1. `document.getElementById(ELEM_ID)` - это метод поиска элемента по его идентификатору (по значению атрибута `id`). Принимает в аргументе идентификатор элемента, который мы хотим найти. Несколько важных моментов:

 - он ищет по ВСЕМУ документу, и не может быть применен для поиска внутри конкретного DOM-узла;
 - если в документе есть несколько элементов с одним и тем же идентификатором, то ~~это плохо спроектированная разметка~~ он вернет первый в документе элемент с таким идентификатором.

2. `document.querySelector(SELECTOR)` - наиболее часто используемый метод поиска. В аргументе принимает CSS-селектор. Также, два важных момента:
 - может быть применен для поиска среди потомков конкретного элемента (`element.querySelector()`);
 - если в документе несколько элементов удовлетворяют критерию поиска, то вернет первый в документе

3. `document.querySelectorAll(SELECTOR)` - также часто используемый метод, принимает в аргументе CSS-селектор, и возвращает массивоподобный объект (NodeList), который содержит множество элементов, удовлетворяющих критерию отбора.

 - также может быть применен для поиска среди потомков конкретного элемента;
 - если в области поиска только один элемент удовлетворяет критерию, то вернет NodeList с одним элементом (то есть работаем как с массивом)
 - если нет подходящих элементов - вернет пустой массив.

Есть еще несколько методов, `getElementsBy*`, но они считаются устаревшими.

**Закрепим практикой**
1. Найти в документе div с классом `inputsBlock`. Результат поиска запишем в переменную `inputsBlock`.
2. Внутри блока из предыдущей задачи, найти все инпуты
3. Найти все кнопки внутри блока `inputsBlock`.
4. Внутри блока `inputsBlock` найти блок с классом `buttonContainer`.
5. Задача со звездочкой. Найти параграф внутри div с классом `buttonContainer`.
6. Задача со звездочкой. Найти кнопки внутри `inputsBlock`, которые являются его прямыми потомками.

**Управление DOM-элементами**
Теперь, когда мы умеем искать по DOM-дереву, мы можем переходить к управлению его содержимым. Начнем с простого - с изменения существующих элементов. Под изменением подразумевается изменение его свойств - добавление обработчиков, изменение содержимого (например текста, или значения, или стилей - да чего угодно).

Нельзя просто взять и изменить элемент - сначала его надо найти. Поэтому, если мы хотим поменять элемент, мы должны его найти одним из тех методов поиска, о которых мы говорили ранее. Когда мы находим элемент - он полностью в нашей власти, и мы можем делать все, что хотим.

Рассмотрим на примере. Предположим, я хочу найти кнопку с id=secondOuterButton, и изменить ей текст на "Click Me!".

```
// ищем кнопку по идентификатору
const btn = document.querySelector('#secondOuterButton');
// теперь в переменную btn записан ОБЪЕКТ, который соответствует ЭЛЕМЕНТУ (нашей кнопке). Все изменения на объекте отразятся на элементе.

// управляем ее текстом - за текст отвечает свойство textContent.
btn.textContent = 'Click Me!';
// Бинго, наша кнопка поменяла текст
```

Набор свойств и методов определяется элементом. Например, у параграфа не будет свойства `value` (оно ему бесполезно). У инпутов будет свойство `placeholder` - типа подсказка, перед тем как пользователь что-то введет. И так далее.

Еще очень существенный момент. Мы можем управлять стилями элемента из JS. За это отвечает свойство `style`, оно содержит объект со стилями. И мы можем эти стили менять. Например, добавим нашей кнопке из предыдущей задачи, красный фон. И удалим рамку. А текст сделаем белым.

```
btn.style.backgroundColor = 'red';
btn.style.color = 'white';
btn.style.border = 'none';
```

Отличие от CSS - вместо тире используем camelCase. То есть, background-color записываем как backgroundColor, border-radius - записываем как borderRadius. И т.д. ВАЖНО! Значения этих свойств ВСЕГДА пишем как строки! То есть, например, `marginRight = '20px'`.

Отдельно стоит упомянуть работу с CSS-классами. Зачастую, мы хотим добавить/убрать класс для элемента. Например, подсветить поле как некорректно заполненное - добавить класс `errorInput`, а потом убрать его. Для этого, рекомендуется использовать свойство `classList`. Оно предоставляет нам несколько очень полезных методов, а именно:

 - add(className) - добавить CSS-класс
 - remove(className) - удалить CSS-класс
 - toggle(className) - если у элемента сейчас есть класс, то убрать его. Если еще нет - добавить (работает как переключатель).

Пример: добавим кнопке класс `simpleButton`, и уберем его.
```
const btn = document.querySelector('#firstInnerButton');
btn.classList.add('simpleButton'); // класс добавлен
btn.classList.remove('simpleButton'); // класс убран
```

**Закрепим практикой**
1. Найти кнопку с id=firstInnerButton, и сделать ей текст `Click me too!`.
2. Этой же кнопке, добавить внутренние отступы (padding) = 10px, цвет фона - синий, цвет текста - белый. Рамку убрать.
3. Кнопке с id=firstOuterButton добавить класс `simpleButton`.
3. Всем инпутам на странице добавить класс `simpleInput`.

И наконец, поговорим о добавлении DOM-элементов на страницу. Иногда нам это нужно. Например, мы получили ответ от сервера, с данными о списке товаров и нам нужно их отрисовать на странице. Или хотим отрисовать какой-то блок, который появится как реакция на действие пользователя.  И так далее.

Чтобы добавить на страницу DOM-элемент, его сначала надо создать. В этом нам поможет метод `document.createElement`. Он СОЗДАЕТ DOM-элемент. Просто создает - но не добавляет в разметку. То есть, после выполнения этого метода, в памяти будет создан объект, будет создан DOM-элемент, но в разметке мы его не увидим. Чтобы он показался, надо явно указать, где в существующей HTML-разметке мы хотим его разместить. Мы также можем до размещения элемента присвоить ему все необходимые свойства. Например, создадим параграф с текстом "Hello".

```
const newParagraph = document.createElement('p'); // создаем элемент. В аргументе передаем имя тега
newParagraph.textContent = 'Hello';
```

Все, наш элемент создан, и готов к добавлению на страницу. Осталось его добавить. Чтобы добавить, мы должны указать, куда мы хотим его добавить. В этом нам поможет несколько методов. Все эти методы вызываются для какого-то конкретного DOM-элемента (назовем его target), то есть мы сначала его находим, а затем вызываем методы.
 - `append` - добавить элемент в конец элемента target. То есть, сделать добавляемый элемент последним потомком элемента target
 - `prepend` - сделать добавляемый элемент первым потомком элемента target
 - `before` - добавить элемент перед элементом target (сделать соседом сверху)
 - `after` - добавить элемент после элемента target (сделать соседом снизу)

Это не исчерпывающий список методов, но пока хватит.

Пример. Нам нужно в div с классом `buttonContainer` добавить еще одну кнопку. Ее мы хотим добавить в конец (то есть сделать последним потомком).
```
const container = document.querySelector('.buttonContainer');
const newButton = document.createElement('button');
newButton.textContent = 'New button';
container.append(newButton);
```

Или, допустим, нам нужно добавить параграф с текстом "Buttons block finished" под div с классом `buttonContainer`.
```
const newParagraph = document.createElement('p');
newParagraph.textContent = 'Buttons block finished';
container.after(newParagraph);
```

**Закрепим практикой**
1. Под div с ID inputsBlock, добавить заголовок h3 с текстом Hello World!
2. Перед кнопкой с id=secondInnerButton, добавить новую кнопку с текстом `New Button`
3. Добавить параграф с текстом Start в начало div с ID inputsBlock
4. Добавить параграф с текстом End в конец div с ID inputsBlock

**Работа с событиями**
Львиную долю всей динамики на странице обеспечивают события. И события происходят в очень большом количестве практически постоянно. Просто большинство из них игнорируется нашими скриптами и браузером. Мы передвинули курсор - событие. Иы навели курсор на элемент - событие. Клики, нажатия клавиш, прокрутка, загрузка скриптов - это все события, которые происходят на нашем веб-проекте. И мы можем на них реагировать - то есть обрабатывать.

Чтобы обработать событие, нужен обработчик. Обработчик - это обычная функция, которую мы определяем, а вот вызываться она будет тогда, когда наступит то событие, которое мы хотим обрабатывать. Причем не просто наступит - а наступит на том элементе, на который мы добавили обработчик.

Пока звучит мутно. Рассмотрим практический пример. У нас полно кнопок - давайте добавим обработчик события клика на одну из них, на кнопку с id=firstInnerButton. Пока что будем просто выводить в консоль сообщение о факте клика.

```
const btn = document.querySelector('#firstInnerButton');
btn.onclick = function() {
  console.log('Click!');
}
```

Теперь мы реагируем на клики по этой кнопке.

Есть важный момент. Так как мы назначили обработчик на кнопку с использованием свойства onclick, то если мы в будущем перезапишем это свойство - то предыдущий обработик будет перезаписан, и вызываться не будет.

Есть ли возможность добавить несколько обработчиков на событие? Да, есть. В этом нам поможет метод `addEventListener`. Дословно - добавить слушатель события. То есть, мы добавляем слушатель какого-то события на DOM-элемент. Как только на этом элементе происходит это событие - будет выполнен обработчик.

```
const btn = document.querySelector('#firstInnerButton');
btn.addEventListener('click', function() {
  console.log('First handler. Click!');
});
btn.addEventListener('click', function() {
  console.log('Second handler. Click!');
});
```

Теперь на нашей кнопке навешено два независимых обработчика события клика. Метод `addEventListener` первым аргументом ожидает строку с именем события, а вторым - функцию-колбэк, которая будет вызвана при наступлении события. Вот пример, где колбэк определен отдельно.

```
function handleClick() {
  console.log('Hanlde Click');
}

btn.addEventListener('click', handleClick);
```

Обратите внимание, как мы передаем колбэк - БЕЗ КРУГЛЫХ СКОБОК!!! Потому что нам нужно передать не результат вызова колбэка, а именно сам колбэк.

Событий в браузере великое множество, и посему все их знать невозможно. Наиболее распространенные:
 - click - клик мышью
 - keydown - нажатие клавиши (момент когда "опускаем" клавишу)
 - keyup - момент когда "отпускаем" клавишу
 - change - изменение значения в текстовом поле, выбор значения в выпадающем списке - короче, изменение значения
 - input - событие ввода
 - blur - событие утери фокуса

Разумеется, не все события применимы ко всем элементам. Скажем, событие `change` вряд ли произойдет на параграфе - потому что у него нет значения. Вот событие `click` может произойти где угодно.

**Закрепим практикой**
1. На событие клика по кнопке с id=secondInnerButton добавить обработчик, который будет выводить в консоль текст "Clicked on inner button".
2. На событие утери фокуса в инпуте с id=ageInput, добавить обработчик, который будет выводить в консоль то, что введено в этот инпут (свойство value)
3. Добавить на ВСЕ инпуты документа обработчик события изменения - который будет выводить в консоль текст "changed".

Теперь еще углубимся в события. Зачастую, нам мало просто факта наступления события - нам нужны какие-то детали. Например, мы кликнули мышью - мы хотим знать, по какому конкретно элементу кликнули. Или мы что-то ввели в текстовое поле - хотим знать, что конкретно ввели. То есть, нам нужны детали события. И в этом нам помогает объект `Event` - то есть объект, который содержит информацию о событии. Этот объект создается браузером в момент наступления события, и этот объект будет передаваться как первый аргумент в функцию-обработчик.

Рассмотрим пример. Мы хотим вывести в консоль информацию о событии, которое происзодит при клике мышью на кнопку secondInnerButton.
```
const btn = document.querySelector('#secondInnerButton');
btn.addEventListener('click', (event) => {
  console.log(event);
});
```

В консоли, мы увидим объект с огромным количеством свойств. Подавляющее большинство нам никогда не пригодится. Особое внимание заслуживает свойство `target` - оно содержит ссылку на тот DOM-элемент, на котором произошло событие (то есть, инициатор). Давайте, например, попробуем при событии изменения инпута, выводить в консоль его идентификатор, и текущее значение.

```
const input = document.querySelector('#firstnameInput');
input.addEventListener('change', (event) => {
  console.log(`Changed input with ID=${event.target.id}, current value is: ${event.target.value}`);
})
```

Как мы уже говорили ранее, событий есть великое множество, и в зависимости от типа события, будет различаться набор свойств объекта-события. Например, у события клавиатуры будет свойство keyCode - числовой код нажатой клавиши. У событий мыши будут координаты относительно вьюпорта. И так далее.

**Закрепим практикой**
1. На кнопку с id=firstOuterButton, добавить обработчик, который будет выводить в консоль текст "First outer btn clicked!".
2. Реализовать подсчет кликов по кнопке с id=firstOuterButton. Нужно чтобы при клике, в консоль выводилось бы количество кликов. Для этого, нам понадобится отдельная переменная-счетчик.
3. Добавить под эту кнопку параграф с текстом "Count: 0". При каждом клике на кнопку, менять текст этого параграфа на текст с актуальным количеством кликов.
4. Добавить на все кнопки документа обработчик события клика, чтобы при клике выводилось в консоль сообщение "Clicked on button with id=BUTTON_ID", то есть чтобы выводился текст с идентификатором кнопки.
5. На событие утери фокуса в инпуте с id=firstnameInput, добавить обработчик. Он должен выводить в консоль слово `Empty!`, если в инпуте пустое значение.
6. На событие утери фокуса в инпуте с id=firstnameInput, добавить обработчик. Он должен посмотреть, есть ли в инпуте значение. Если нет - добавить этому инпуту класс `errorInput`. Если есть - убрать этот класс.
7. На событие клика по кнопке с id=firstOuterButton, добавить обработчик, который проверит, есть ли в инпутах firstnameInput, lastnameInput значения. Если хотя бы в одном значение пустое - выводить в консоль сообщение "Error".


### Полезные ссылки
 - Разде (учебника)[https://learn.javascript.ru/ui], посвященный DOM, событиям, и т.д. Рекомендуется прочитать и понять весь раздел!