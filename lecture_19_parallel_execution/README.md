# README

## Лекционное занятие №19

### Тема:

Репозитарий содержит материалы по лекционному занятию №19, посвященному параллельносу выполнению промисов.

### Разогрев
1. Что выведет код?
```
async function firstFunction() {
  console.log('Start');
  const myPromise = new Promise( (resolve, reject) => {
    resolve('Result');
  });
  const result = await myPromise;
  console.log(result);
  console.log('Finish');
}

firstFunction();
console.log('After');
```

2. Что выведет код?
```
async function firstFunction() {
  console.log('Start');
  const myPromise = new Promise( (resolve, reject) => {
    console.log('In Promise');
    resolve('Result');
  });
  const result = await myPromise;
  console.log(result);
}

firstFunction();
console.log('After');
```

3. Что выведет код?
```
async function firstFunction() {
  console.log('Start');
  const myPromise = new Promise( (resolve, reject) => {
    console.log('In Promise');
    resolve('Result');
  });
  const result = await myPromise;
  console.log(result);
  return 'Function Result';
}

const res = firstFunction();
console.log(res);
console.log('After');
```

**Зачем это нужно**
Очень часто в работе возникают ситуации, когда нужно выполнить несколько асинхронных операций, дождаться из результата, и только потом продолжать нормальную работу. И зачастую, эти операции можно выполнять параллельно.

Рассмотрим пример. Мы пишем банковское приложение, и нам нужно дать пользователю возможность сделать перевод по SWIFT. Нам нужно при заходе на соответствующую страницу нашего приложения, выполнить 2 запроса: запросить у бэка справочник курсов валют, и запросить справочник стран. Пусть первый запрос займет А секунд, а второй Б секунд. Мы не знаем, какой из них выполнится быстрее, но мы знаем, что для нормальной отрисовки нашей страницы, нам нужны результаты обоих. То есть, нам нужно их дождаться.

Можно запустить оба запроса последовательно - то есть отправить запрос валют, дождаться результата, и затем отправить запрос стран. Но тогда время ожидания будет А + Б секунд.

А можно отправить оба запроса одновременно, и сказать, что отрисовка страницы начнется тогда, когда выполнятся ОБА эти запроса. Для этого есть специальный метод у `Promise`, имя ему `all`. Он принимает на вход массив промисов, и дожидается выполнения всех этих промисов  (или же первого нештатного завершения какого-то из этих промисов). И после этого, выполняет свою логику.

```
function requestRates() {
   return new Promise( resolve => {
      setTimeout( resolve, 1500, ['BYN', 'RUR', 'UAH', AMD']);
   })
}

function requestCountries() {
   return new Promise( resolve => {
      setTimeout( resolve, 2500, ['Belarus', 'Russia', 'Ukraine', 'Armenia']);
   })
}

Promise.all( [requestRates(), requestCountries()] )
   .then( results => console.log(results) );
```

Если мы засечем время выполнения, мы увидим, что `then` сработал спустя примерно 2.5 секунды после запуска (то есть время, которое нужно было для резолва самого долгого промиса из массива). И результатом будет также МАССИВ, который будет содержать результаты промисов (в нашем случае - массивы с именами валют и стран).

Резюмируя: `Promise.all` принимает на вход массив с промисами. Затем, ждет:
 - или пока все промисы будут успешно выполнены
 - или пока один из промисов будет завершен неуспехом.

`Promise.all` возвращает промис.

В случае, если все промисы-аргументы будут успешно выполнены, то тот промис, который возвращает `Promise.all`, будет успешно завершен массивом с результатами промисов-аргументов.

Если же нет - то он будет завершен неуспехом, с той ошибкой, которая случилась в промисе-аргументе.

```
const first = new Promise( resolve => setTimeout(resolve, 1500, 'First promise') );
const second = new Promise( resolve => setTimeout(resolve, 2500, 'Second promise') );
const third = new Promise( (resolve, reject) => setTimeout(reject, 1500, new Error('Bad promise')) );

const goodPromises = Promise.all( [first, second] );
const notAllGoodPromises = Promise.all( [first, second, third] );

// Через 2.5с мы увидим это в консоли - т.к. оба промиса будут успешно завершены
goodPromises.then( results => console.log(results) );

notAllGoodPromises
   // это мы не увидим в консоли - потому что один из промисов завершится ошибкой
   .then( results => console.log('Not all good', results))
   // вот это мы увидим в консоли
   .catch( err => console.log('That happened', err));
```

**Закрепим практикой**
1. Создать 2 промиса. Первый должен быть зарезолвлен через 1 секунду числом 10, второй - через 2 секунды, числом 15. Дождаться выполнения обоих промисов, и вывести в консоль слово `fulfilled`.
2. Дорабатываем задачу из п.1. Теперь надо вывести в консоль сумму результатов промисов.
3. В скрипте есть функция `randomPromiseCreator`. С ее помощью, создать 3 промиса, дождаться выполнения их всех. В случае успеха - вывести в консоль результаты промисов. В случае неуспеха - вывести причину ошибки.
4. Пишем функцию `requestProductsAndCategories`. Она должна обратиться к адресам `https://dummyjson.com/products`, `https://dummyjson.com/products/categories`, дождаться результатов ОБОИХ запросов, и вернуть ОБЪЕКТ, у которого будет свойство `products` с данными товаров, и свойство `categories` с данными категорий..
5. Пишем функцию `sendMultipleRequests`. Эта функция должна принять произвольное количество аргументов - строк с адресами, к которым мы хотим обратиться (методом GET). И нужно дождаться ответа по всем адресам, преобразовать все результаты в json, и вернуть массив с результатами запросов.

**Работа с Promise.race**
Доселе, мы рассматривали только ситуацию "все или ничего" - то есть или все промисы завершатся успешно, или ничего не выполнится и случится ошибка. Иногда бывают ситуации, когда нам нужно добиться противоположного эффекта - а именно, нас интересует только самый первый успешно завершившийся промис, а все остальные нужно проигнорировать. То есть, у нас как бы состояние гонки - кто первый пришел, тот и победил, а остальные не интересны.

Для этого, существует `Promise.race`. Он точно так же принимает массив промисов, но вернет результат первого завершенного промиса (успех или ошибку).
```
const first = new Promise( resolve => setTimeout(resolve, 1500, 'First promise') );
const second = new Promise( resolve => setTimeout(resolve, 2500, 'Second promise') );
const third = new Promise( (resolve, reject) => setTimeout(reject, 500, new Error('Bad promise')) );

const goodPromises = Promise.race( [first, second] );
const allPromises = Promise.race( [first, second, third] );

// Через 1.5с в консоли будет результат первого промиса (он завершится раньше второго)
goodPromises.then( results => console.log(results) );

allPromises
   // это мы не увидим в консоли - потому что самый быстрый промис завершится ошибкой
   .then( results => console.log('Not all good', results))
   // вот это мы увидим в консоли
   .catch( err => console.log('That happened', err));
```

**Закрепим практикой**
1. Создать 2 промиса, первый должен быть успешно завершен числом 76 спустя 1.5 секунды, а второй - числом 106, спустя 2 секунды. С помощью `Promise.race` дождаться того, кто завершится первым, и вывести результат в консоль.
2. У нас есть функция `makeRacer`, она создает гонщика для заезда. Нужно создать нескольких гонщиков, и с помощью `Promise.race` имитировать заезд.

**Еще немного о совместном выполнении**
Это были два наиболее известных метода для параллельного выполнения промисов, но это не все методы. Еще есть `Promise.allSettled, Promise.any`, и о них можно прочитать по одной из полезных ссылок.

### Полезные ссылки
 - Русскоязычный гайд [async/await](https://learn.javascript.ru/async-await).
 - [Раздел про промисы](https://learn.javascript.ru/promise-api) - это раздел учебника, посвященный промисам. Также настоятельно рекомендуется к прочтению - по этой теме стопроцентно будут вопросы на собеседованиях.