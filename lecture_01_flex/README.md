# README

## Лекционное занятие №1

### Тема:

Репозитарий содержит материалы по лекционному занятию №1, посвященному повторению CSS и разметки. Основная тема - верстка с помощью flex-контейнеров.

### Верстка и стили (повторение)
Для того, чтобы стилизовать наши веб-проекты, добавить в них красоты и обеспечить соответствие дизайну, мы используем стили CSS (Cascading Style Sheets). На базовом курсе были изложены азы верстки, и основы работы со стилями. На нашем первом занятии, мы поговорим о таких вещах как позиционирование, и верстка с помощью флекс-контейнеров (flexbox).

### Позиционирование
Чтобы понять позиционирование, нужно рассмотреть несколько дополнительных, вспомогательных понятий. И первое из них - это "нормальный поток" HTML-элементов. Что же это такое?
Когда мы размещаем на странице какой-либо элемент, он встраивается в иерархию DOM-элементов. И эти элементы размещаются в так называемом "нормальном потоке". В основном, они занимают всю доступную ширину своего контейнера (элемента-родителя), и размещаются один под другим. Ранее, их было принято называть блочными элементами, потому что они создают "блок" на странице. Примерами таких элементов могут служить `div`-ы на нашей странице `index.html`. Кроме этого, у нас есть заголовки (h1-h6), параграфы (p) и многие другие примеры блочных элементов. Также у нас есть строчные элементы, которые занимают столько пространства, сколько нужно их содержимому. Пример - теги `span`.

В базовом, не-позиционированном варианте, когда мы размещаем на странице элементы, то блочные идут один под другим (как бы размещаются в столбик). При этом, элементы не "наползают" друг на друга, то есть не перекрывают. И зачастую, нас это устраивает. Но иногда мы хотим добиться иного поведения - например:
 - разместить какой-то элемент над другими элементами.
 - разместить элемент над другими, но и сказать всем остальным элементам, что они должны заполнить оставшееся от основного элемента место.
 - сместить элемент относительно его нормальной позиции
 - сместить элемент относительно кого-то из родителей

И тут нам как раз пригодится позиционирование.

За позиционирование элемента отвечает свойство `position`.

```
div.positioned {
  // ...
  position: relative;
  // ...
}
```

У нас в разметке присутствует блок с классом `experimental` - сегодня мы с ним поэкспериментируем и попробуем разные варианты позиционирования.

**Какие существуют варианты позиционирования?**
1. `static` - это вариант "по умолчанию". То есть, если у элемента не указано значение свойства `position`, то по умолчанию браузер считает `position: static`. Статическое позиционирование, по сути, означает: "тебе не нужно никак менять свое положение в потоке элементов, просто существуй".
2. `relative` - это уже вариант поинтереснее. Здесь мы как бы говорим элементу "мы хотим, чтобы остальные элементы вели себя так, как будто ты существуешь, но при этом, возможно, мы захотим тебя подвинуть". То есть это сигнализирует остальным элементам не занимать место текущего элемента, но при этом дает нам возможности смещения текущего элемента относительно своей "нормальной" позиции.
 - Чаще всего, такой вариант используется, когда мы хотим оставить этот элемент на его месте, но позиционировать кого-то из его **потомков** относительно этого элемента. Мы поговорим об этом чуть позже.
 - Также, такой вариант используется, если мы хотим сместить элемент относительно его текущей позиции, но при этом остальные элементы не должны занимать его место.

Примером второго варианта будет следующий блок кода:
```
.experimental {
  position: relative;
  top: 10px;
  left: 10px;
}
```

Мы можем видеть, что при таком стиле, наш экспериментальный блок как бы "сместился" влево и вниз на 10 пикселей. Как это произошло? Потому что мы ему сказали, что он будет позиционирован относительно своей "нормальной" позиции. И должен сместиться на 10 пикселей вниз относительно верхней границы своей нормальной позиции. И также на 10 пикселей вправо относительно левой границы своей нормальной позиции. Также обратим внимание, что следующий за ним блок отнесся к этому со всем уважением, и не кинулся занимать место блока `experimental`.

**Закрепим упражнением**
 - в блоке `experimental` у нас присутствует заголовок `h3` с классом `experimentalHeader`. Сделайте так, чтобы заголовок сместился вправо относительно своей нормальной позиции на 20 пикселей.
 - сделайте так, чтобы заголовок сместился вверх относительно нормальной позиции на 15 пикселей.
 - задача со звездочкой. Сместите заголовок ВЛЕВО относительно его нормальной позиции на 30 пикселей, при этом используйте свойство `left`.

3. `absolute` - абсолютное позиционирование. Это также может нам помочь управлять смещением, но кроме этого, такая конструкция как бы "забирает" элемент из нормального потока. То есть говорит всем остальным элементам: "ведите себя так, как будто этого элемента не существует". И остальные элементы радостно займут освободившееся пространство.

И вот тут возникает интересный (надеюсь) вопрос. Если элемент изымается из нормального потока, то относительно каких границ мы будем его смещать свойствами `top / left / bottom / right`? И вот тут - очень важный момент. Элемент будет смещаться относительно границ **ближайшего позиционированного родителя**, то есть ближайшего родителя, у которого есть position, и position != static. Если таковой родитель в иерархии не обнаружен - то относительно `body`.

Кроме этого, элемент будет занимать ширину своего содержимого (то есть блочные элементы перестают занимать всю ширину).

Давайте в этом убедимся. Сделаем параграф из блока `experimental` абсолютно позиционированным.
```
.experimental p {
  position: absolute;
}
```

Что мы видим? Что параграф теперь занимает ровно столько места, сколько нужно его содержимому. Кроме этого, параграф сместился - теперь он "прижат" к левому верхнему углу ближайшего родителя, у которого не статическое позиционирование. И кнопка, которая раньше была под параграфом, теперь занимает его место. То есть, наш параграф изъят из нормального потока, и все остальные элементы ведут себя так, как будто его нет.

Где может быть полезно абсолютное позиционирование (пара базовых примеров)?
 - анимации (например, слайдеры)
 - модальные окна, диалоговые окна
 - кнопки типа "закрыть окно" для диалогов

**Закрепим упражнением**
 - в блоке `experimental` у нас присутствует кнопка. Изначально она имеет статическое позиционирование. Сделайте так,чтобы она была прижата к нижнему правому углу контейнера, и размещалась поверх остальных элементов.
 - Сделайте так, чтобы кнопка размещалась НАД правым верхним углом экспериментального блока.

4. `fixed` - это подвид абсолютного позиционирования, который используется тогда, когда нам нужно позиционировать наш элемент относительно окна. То есть сделать так, чтобы при прокрутке, он не менял бы свое положение. Зачастую используется для фиксированных заголовков (fixed headers), или плавающих кнопок (floating buttons).
5. `sticky` - а это "подвид" фиксированного позиционирования. При "доскролливании" до такого элемента, он "прилипает" к верхней границе, и дальше ведет себя как `fixed`.

### CSS Flexbox
Теперь, пришла пора поговорить о флекс-контейнерах. О них наверняка говорили на базовом курсе - мы же сегодня попробуем это закрепить.

Итак, флексбокс. Зачем он нужен, и чем может помочь? Он нам помогает в верстке более сложных макетов, например когда мы хотим разместить несколько блочных элементов в строку. До появления этой классной штуки, такие задачи решались и через `display: table`, и через `float` (плавающие блоки), но с появлением флексов ситуация значительно изменилась к лучшему.

В чем же идея? В том, что у нас есть некий элемент-контейнер (он так и называется, флекс-контейнер), а в нем есть его прямые (!) потомки, т.н. "флекс-элементы". И мы можем с помощью ряда СSS-правил сказать контейнеру, как бы мы хотели упорядочить элементы-потомки. А контейнер будет стараться это сделать оптимальным образом: он будет менять ширину и/или высоту потомков, растягивая/сжимая их, чтобы заполнить доступное свободное пространство (или уместить потомки в контейнер).

Пока непонятно, но попробуем разобраться, как будет работать флекс-контейнер.

Первое, что следует отметить: флекс-контейнер имеет две оси, основную и вспомогательную. Когда мы добавляем во флекс-контейнер элементы, он размещает их вдоль основной оси. Нетрудно догадаться, что этими осями могут быть ось Х и У на экране, то есть горизонтальная и вертикальная оси. Кто из них будет основной, а кто вспомогательной - мы можем об этом сказать флекс-контейнеру, для этого у нас есть свойство `flex-direction`. Разберем возможные значения.
 - `row`. Это значение по умолчанию. В этом случае, основная ось будет горизонтальная, и направлена слева направо. Верикальная ось будет вспомогательной.
 - `column`. В этом случае, основной осью будет вертикальная ось, и направлена она будет сверху вниз.
 - `row-reverse`. Основная ось горизонтальная, но направлена справа налево.
 - `column-reverse`. Основная ось вертикальная, но направлена снизу вверх.

 Рассмотрим пример. У нас есть контейнер `div.flexContainer`. Он содержит несколько потомков (цветные кубики). Попробуем поэкспериментировать с `flex-direction` для контейнера, и посмотреть, как будет меняться расположение потомков.

 Теперь поговорим о выравнивании потомков. Мы можем сказать флекс-контейнеру, как он должен выравнивать расположение потомков относительно основной и вспомогательной осей. Имеется в виду, как контейнер должен распределить свободное пространство между потомками. За выравнивание по основной оси отвечает свойство `justify-content`, за выравнивание по вспомогательной - `align-items`. Поэкспериментируем с выравниванием потомков.

 **Закрепим практикой**
На странице представлен блок `div.experimentalFlexContainer`. В нем есть также несколько цветных кубиков.
 - Сделайте так, чтобы они размещались в строку, и при этом свободное пространство было равномерно распределено вокруг них (кубики по центру, справа-слева отступы)
 - сделайте так, чтобы свободное пространство распространялось равномерно между границами кубиков и границами контейнера
 - сделайте так, чтобы кубики были в столбик, и при этом этот столбик был выровнян по центру.

Теперь поговорим о том, что делать контейнеру, если в него не помещаются элементы. Например мы пытаемся сложить в контейнер кубики, чья суммарная ширина больше ширины контейнера. В этом случае, мы можем:
 - попросить контейнер "сжать" кубики
 - сказать контейнеру при переполнении перевести на новую строку (или новый столбец)

За это отвечает свойство `flex-wrap`. По умолчанию, контейнер будет пытаться "упихать" все потомки без переноса на новую строку/столбец. Если нам нужно разрешить перенос - ставим свойство `flex-wrap: wrap`.

До сих пор, мы говорили только о свойствах, которые нужно применять к контейнеру. Но кроме этого, у нас есть свойства, которые можно применять к потомкам! Обычно это нужно, если мы хотим сказать потомку, что он должен себя вести как-то иначе, чем остальные. Например, все выровнены по вспомогательной оси по центру, а конкретный потомок должен быть выровнен по верхнему краю. За это отвечает свойство `align-self`.

Рассмотрим пример. Зададим флекс-контейнеру жестко заданную высоту, чтобы он был выше своих потомков. С учетом того, что у нас `flex-direction: row`, вспомогательной осью будет вертикальная. Мы можем выровнять все потомки (кубики) по вертикали по центру, с использованием `align-items: center` для контейнера. И мы можем сказать кому-то конкретному (например, первому кубику), что он должен быть выровнен по верхнему краю. И вот именно ему (флекс-элементу), мы скажем `align-self: flex-start`;

**Закрепим практикой**
Контейнеру `div.experimentalFlexContainer`, сделать фиксированную высоту 300 пикселей. С помощью `align-self`, выровнять потомков так, чтобы они рисовались "лесенкой". Первый кубик прижат к верхнему краю, второй выровнен по центру, третий прижат к нижнему краю.

Теперь рассмотрим более практический пример. Допустим, нам надо сверстать шапку для сайта, которая содержит логотип (он должен быть прижат к левому краю), навигационное меню (по центру шапки), и блок с кнопками входа и регистрации (прижаты к правому краю). Давайте вместе подумаем, как мы могли бы решить эту задачу с помощью флекс-контейнеров.

### Домашнее задание
Сверстать сайт по [макету](https://www.figma.com/design/ntTbBfeG8m53kLoriar4QX/Untitled?node-id=1-228).

### Полезные ссылки
 - Гайд по [позиционированию](https://learn.javascript.ru/position) - информативно, подробно, на русском языке.
 - Русскоязычный гайд по [flexbox](https://habr.com/ru/articles/467049/). Это перевод с комментариями, оригинал [здесь](https://css-tricks.com/snippets/css/a-guide-to-flexbox/).
 - еще русскоязычный гайд по [флексам](https://medium.com/@stasonmars/%D0%B2%D0%B5%CC%88%D1%80%D1%81%D1%82%D0%BA%D0%B0-%D0%BD%D0%B0-flexbox-%D0%B2-css-%D0%BF%D0%BE%D0%BB%D0%BD%D1%8B%D0%B8%CC%86-%D1%81%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA-e26662cf87e0)